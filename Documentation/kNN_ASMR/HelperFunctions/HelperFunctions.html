<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>kNN_ASMR.HelperFunctions.HelperFunctions API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kNN_ASMR.HelperFunctions.HelperFunctions</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kNN_ASMR.HelperFunctions.HelperFunctions.bl_th"><code class="name flex">
<span>def <span class="ident">bl_th</span></span>(<span>l, ss)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bl_th(l, ss):
    
    &#39;&#39;&#39;
    Computes Legendre expansion coefficients for the top-hat window function in angular coordinates.

    #-----------------------------------------------------------------------------------------------
    
    Parameters
    ----------
    
    l: int array
        array of multipole numbers.

    ss: float
        angular scale (in radians) at which the field is to be smoothed.

    #-----------------------------------------------------------------------------------------------

    Returns
    -------

    num/den: float array of same size as input array &#39;l&#39;
        array of Legendre expansion coefficients at each input multipole number.
    &#39;&#39;&#39;

    plm1 = scipy.special.eval_legendre(l-1, np.cos(ss))
    plp1 = scipy.special.eval_legendre(l+1, np.cos(ss))
    num = (plm1-plp1)
    den = (2*l+1)*(1-np.cos(ss))
    return num/den</code></pre>
</details>
<div class="desc"><p>Computes Legendre expansion coefficients for the top-hat window function in angular coordinates.</p>
<h1 id="-">-----------------------------------------------------------------------------------------------</h1>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>int array</code></dt>
<dd>array of multipole numbers.</dd>
<dt><strong><code>ss</code></strong> :&ensp;<code>float</code></dt>
<dd>angular scale (in radians) at which the field is to be smoothed.</dd>
</dl>
<h1 id="-_1">-----------------------------------------------------------------------------------------------</h1>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>num/den: float array</code> of <code>same size as input array 'l'</code></dt>
<dd>array of Legendre expansion coefficients at each input multipole number.</dd>
</dl></div>
</dd>
<dt id="kNN_ASMR.HelperFunctions.HelperFunctions.calc_kNN_CDF"><code class="name flex">
<span>def <span class="ident">calc_kNN_CDF</span></span>(<span>vol, kMax, bins)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_kNN_CDF(vol, kMax, bins):

    &#39;&#39;&#39;
    Returns the kNN-CDFs for the given nearest-neighbour distances, evaluated at the given distance
    bins.

    #-----------------------------------------------------------------------------------------------
    
    Parameters
    ----------
    
    vol: float array of shape (n, l) where &#39;n&#39; is the number of query points and &#39;l&#39; is the number
         of nearest neighbours queried
        Sorted array of nearest neighbour distances.
        
    kMax: int
        the number of nearest neighbours to calculate the distances to. For example, if kMax = 3, 
        the first 3 nearest-neighbour distributions will be computed.

    bins: list of float arrays
        list of distances for each nearest neighbour. The i^th element of the list should contain a
        numpy array of the desired distances for the i^th nearest neighbour.

    #-----------------------------------------------------------------------------------------------

    Returns
    -------

    data: list of float arrays, each of shape len(bins[k-1]) for 1&lt;=k&lt;=kMax
        kNN-CDFs evaluated at the desired distance bins.
    &#39;&#39;&#39;

    #-----------------------------------------------------------------------------------------------
    
    #Initialising the list of kNN-CDFs
    data = []

    #-----------------------------------------------------------------------------------------------

    #Computing the interpolated emperical CDFs using the nearest-neighbour distances
    cdfs = cdf_vol_knn(vol)

    #-----------------------------------------------------------------------------------------------

    #Looping over the nearest-neighbour indices
    for i in range(kMax):

        #-------------------------------------------------------------------------------------------

        #Finding the minimum and maximum values of the NN distances
        min_dist = np.min(vol[:, i])
        max_dist = np.max(vol[:, i])

        #-------------------------------------------------------------------------------------------

        #Finding if any of the user-input bins lie outside the range spanned by the NN distances
        bin_mask = np.searchsorted(bins[i], [min_dist, max_dist])
        if bin_mask[1]!=len(bins[i]):
            if bins[i][bin_mask[1]] == max_dist:
                bin_mask[1] += 1

        #-------------------------------------------------------------------------------------------
                
        NNcdf = np.zeros(len(bins[i]))
        
        #Setting the value of the CDFs at scales smaller than the smallest NN distance to 0
        NNcdf[:bin_mask[0]] = 0
        
        NNcdf[bin_mask[0]:bin_mask[1]] = cdfs[i](bins[i][bin_mask[0]:bin_mask[1]])
        
        #Setting the value of the CDFs at scales larger than the largest NN distance to 1
        NNcdf[bin_mask[1]:] = 1
        
        data.append(NNcdf)
        
    return data</code></pre>
</details>
<div class="desc"><p>Returns the kNN-CDFs for the given nearest-neighbour distances, evaluated at the given distance
bins.</p>
<h1 id="-">-----------------------------------------------------------------------------------------------</h1>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vol</code></strong> :&ensp;<code>float array</code> of <code>shape (n, l) where 'n' is the number</code> of <code>query points and 'l' is the number</code></dt>
<dd>of nearest neighbours queried
Sorted array of nearest neighbour distances.</dd>
<dt><strong><code>kMax</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of nearest neighbours to calculate the distances to. For example, if kMax = 3,
the first 3 nearest-neighbour distributions will be computed.</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>list</code> of <code>float arrays</code></dt>
<dd>list of distances for each nearest neighbour. The i^th element of the list should contain a
numpy array of the desired distances for the i^th nearest neighbour.</dd>
</dl>
<h1 id="-_1">-----------------------------------------------------------------------------------------------</h1>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code> of <code>float arrays, each</code> of <code>shape len(bins[k-1]) for 1&lt;=k&lt;=kMax</code></dt>
<dd>kNN-CDFs evaluated at the desired distance bins.</dd>
</dl></div>
</dd>
<dt id="kNN_ASMR.HelperFunctions.HelperFunctions.cdf_vol_knn"><code class="name flex">
<span>def <span class="ident">cdf_vol_knn</span></span>(<span>vol)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf_vol_knn(vol):
    &#39;&#39;&#39;
    Returns interpolating functions for emperical CDFs of the given \\(k\\)-nearest neighbour distances.
    
    Parameters
    ----------
    vol : numpy array of shape (n, l) where &#39;n&#39; is the number of query points and &#39;l&#39; is the number of nearest neighbours queried
        Sorted array of nearest neighbour distances.

    Returns
    -------
    cdf: list
        list of interpolated emperical CDF functions that can be evaluated at desired distance bins.
    &#39;&#39;&#39;
    
    #-----------------------------------------------------------------------------------------------

    #Initialising a list to contain the interpolating functions
    cdf = []

    #-----------------------------------------------------------------------------------------------

    #Inferring the number of query points and nearest neighbours
    n = vol.shape[0]
    l = vol.shape[1]

    #-----------------------------------------------------------------------------------------------

    #Calculating the emperical CDF
    gof = ((np.arange(0, n) + 1) / (n*1.0))
    for c in range(l):
        ind = np.argsort(vol[:, c])
        s_vol= vol[ind, c]
        #Calculating the interpolating function
        cdf.append(interpolate.interp1d(s_vol, gof, kind=&#39;linear&#39;, bounds_error=False))
        
    return cdf</code></pre>
</details>
<div class="desc"><p>Returns interpolating functions for emperical CDFs of the given <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-nearest neighbour distances.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vol</code></strong> :&ensp;<code>numpy array</code> of <code>shape (n, l) where 'n' is the number</code> of <code>query points and 'l' is the number</code> of <code>nearest neighbours queried</code></dt>
<dd>Sorted array of nearest neighbour distances.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cdf</code></strong> :&ensp;<code>list</code></dt>
<dd>list of interpolated emperical CDF functions that can be evaluated at desired distance bins.</dd>
</dl></div>
</dd>
<dt id="kNN_ASMR.HelperFunctions.HelperFunctions.create_query"><code class="name flex">
<span>def <span class="ident">create_query</span></span>(<span>NSIDE_query, mask, tolerance)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_query(NSIDE_query, mask, tolerance):

    &#39;&#39;&#39;
    Computes the usable query points for the given mask (ie., query points at least a user-defined 
    threshold distance away from the mask edge) and returns the same, along with a HEALPix 
    &#39;query mask&#39; that has the following values:
    
        0: pixels outside the observational footprint
        1: pixels inside the footprint but too close to the mask edge (not usable)
        2: usable pixels

    See Gupta &amp; Banerjee (2024) for a detailed discussion. Currently supports only query grids of the same
    size as the HEALpix grid on which the continuous overdensity field skymap is defined.

    #-----------------------------------------------------------------------------------------------

    References:

        1. Gupta &amp; Banerjee (2024):
        Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources 
        with k-nearest neighbour distributions, Monthly Notices of the Royal Astronomical Society, 
        Volume 531, Issue 4, July 2024, Pages 4619–4639, https://doi.org/10.1093/mnras/stae1424
    
    #-----------------------------------------------------------------------------------------------
    
    Parameters
    ----------
    
    NSIDE_query: int
        the HEALPix NSIDE of the query grid (needs to be the same as that of the continuous field
        and the mask). Must be a power of 2 (eg. 128, 256, 512, etc.)

    mask: int array of shape (12*NSIDE_query**2,)
        array with 0 and 1 indicating that the corresponding HEALPixel is outside and inside the 
        observational footprint, respectively.

    tolerance: float
        the minimum angular distance (in radians) a query point needs to be away from the mask edge
        to be considered usable.

    #-----------------------------------------------------------------------------------------------

    Returns
    -------

    query_mask: float array of same size as input array &#39;mask&#39;
        the HEALPix query mask.

    QueryPositions: float array of shape (N_usable_pix, 3)
        array of usable query point positions (&#39;N_usable_pix&#39; is the number of pixels that are
        sufficiently far away from the mask edge).
    &#39;&#39;&#39;

    #-----------------------------------------------------------------------------------------------

    #Check all inputs are consistent with the function requirement

    #Check if &#39;tolerance&#39; is a valid angle
    if tolerance&lt;0 or tolerance&gt;2*np.pi:
        raise ValueError(&#39;Invalid threshold distance: please ensure 0 &lt;= tolerance &lt;= 2*pi.&#39;)

    #Check if &#39;NSIDE_query&#39; is a power of 2
    if not (NSIDE_query &gt; 0 and (NSIDE_query &amp; (NSIDE_query - 1)) == 0):
        raise ValueError(&#39;Invalid NSIDE for the query grid: please ensure NSIDE is a power of 2&#39;)

    #Getting the NSIDE for the original mask
    NSIDE_mask = hp.get_nside(mask)

    #Check if the NSIDEs match
    if NSIDE_mask!=NSIDE_query:
        raise ValueError(f&#39;NSIDE of the query grid ({NSIDE_query}) does not match NSIDE of \
        the mask ({NSIDE_mask}).&#39;)

    #-----------------------------------------------------------------------------------------------

    #Query points are defined on a Healpix grid, points in or close to the mask are removed

    #Getting number of pixels from the NSIDE for the query points
    NPIX = hp.nside2npix(NSIDE_query)    

    #-----------------------------------------------------------------------------------------------
    
    #Getting the query mask

    #2 means that the query point is usable
    query_mask = 2*np.ones(NPIX)

    pixels = np.arange(NPIX)
    qpos_arr = np.array(hp.pix2vec(NSIDE_query, pixels))
    #Looping over the initial query pixels
    for pix_ind, qpos in enumerate(qpos_arr.T):
        sel_pix_close = hp.query_disc(NSIDE_query, qpos, tolerance)
        #1 means that the query point is close to the mask edge
        if np.any(mask[sel_pix_close]==hp.UNSEEN): query_mask[pix_ind] = 1

    pix_inside_arr = hp.vec2pix(NSIDE_query, qpos_arr[0], qpos_arr[1], qpos_arr[2])
    #0 means that the query point is outside the footprint
    query_mask[mask[pix_inside_arr]==hp.UNSEEN] = 0

    #-----------------------------------------------------------------------------------------------

    #Getting the query positions

    query_pixels = np.arange(NPIX)[query_mask==2]
    
    #Getting the latitudes and longitudes in degrees
    QueryPositions_Deg = np.transpose(hp.pixelfunc.pix2ang(NSIDE_query, query_pixels, lonlat=True))
    QueryPositions_Deg[:, [0, 1]] = QueryPositions_Deg[:, [1, 0]]
    
    #converting to radians
    QueryPositions = np.deg2rad(QueryPositions_Deg)

    return query_mask, QueryPositions</code></pre>
</details>
<div class="desc"><p>Computes the usable query points for the given mask (ie., query points at least a user-defined
threshold distance away from the mask edge) and returns the same, along with a HEALPix
'query mask' that has the following values:</p>
<pre><code>0: pixels outside the observational footprint
1: pixels inside the footprint but too close to the mask edge (not usable)
2: usable pixels
</code></pre>
<p>See Gupta &amp; Banerjee (2024) for a detailed discussion. Currently supports only query grids of the same
size as the HEALpix grid on which the continuous overdensity field skymap is defined.</p>
<h1 id="-">-----------------------------------------------------------------------------------------------</h1>
<h2 id="references">References</h2>
<ol>
<li>Gupta &amp; Banerjee (2024):
Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources
with k-nearest neighbour distributions, Monthly Notices of the Royal Astronomical Society,
Volume 531, Issue 4, July 2024, Pages 4619–4639, <a href="https://doi.org/10.1093/mnras/stae1424">https://doi.org/10.1093/mnras/stae1424</a></li>
</ol>
<h1 id="-_1">-----------------------------------------------------------------------------------------------</h1>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>NSIDE_query</code></strong> :&ensp;<code>int</code></dt>
<dd>the HEALPix NSIDE of the query grid (needs to be the same as that of the continuous field
and the mask). Must be a power of 2 (eg. 128, 256, 512, etc.)</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>int array</code> of <code>shape (12*NSIDE_query**2,)</code></dt>
<dd>array with 0 and 1 indicating that the corresponding HEALPixel is outside and inside the
observational footprint, respectively.</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>the minimum angular distance (in radians) a query point needs to be away from the mask edge
to be considered usable.</dd>
</dl>
<h1 id="-_2">-----------------------------------------------------------------------------------------------</h1>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>query_mask</code></strong> :&ensp;<code>float array</code> of <code>same size as input array 'mask'</code></dt>
<dd>the HEALPix query mask.</dd>
<dt><strong><code>QueryPositions</code></strong> :&ensp;<code>float array</code> of <code>shape (N_usable_pix, 3)</code></dt>
<dd>array of usable query point positions ('N_usable_pix' is the number of pixels that are
sufficiently far away from the mask edge).</dd>
</dl></div>
</dd>
<dt id="kNN_ASMR.HelperFunctions.HelperFunctions.create_smoothed_field_dict"><code class="name flex">
<span>def <span class="ident">create_smoothed_field_dict</span></span>(<span>skymap, bins, query_mask, Verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_smoothed_field_dict(skymap, bins, query_mask, Verbose=False):

    &#39;&#39;&#39;
    Creates a dictionary containing the continuous field smoothed at various angular distance
    scales.

    #-----------------------------------------------------------------------------------------------

    References:

        1. Gupta &amp; Banerjee (2024):
        Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources 
        with k-nearest neighbour distributions, Monthly Notices of the Royal Astronomical Society, 
        Volume 531, Issue 4, July 2024, Pages 4619–4639, https://doi.org/10.1093/mnras/stae1424
    
    #-----------------------------------------------------------------------------------------------
    
    Parameters
    ----------
    
    skymap: float array
        the healpy map of the continuous field that needs to be smoothed.
        The values of the masked pixels, if any, should be set to hp.UNSEEN.

    bins: list of float arrays
        list of distances for each nearest neighbour. The i^th element of the list should contain a
        numpy array of the desired distances for the i^th nearest neighbour.
    
    query_mask: int array of same size as &#39;skymap&#39;
        array with 0, 1 and 2 indicating that the corresponding HEALPixel is outside the mask,
        too close to mask boundary and sufficiently far away from the boundary, respectively.
        Refer to function &#39;create_query&#39; defined above for creating the query mask and see 
        Gupta and Banerjee (2024) for more details).

    Verbose: Binary
        if set to True, the time taken to complete each step of the calculation will be printed.
        Defaults to False.

    #-----------------------------------------------------------------------------------------------

    Returns
    -------

    SmoothedFieldDict: dictionary
        dictionary containing the continuous field masked within the observational footprint and 
        smoothed at various angular distance scales. For example, SmoothedFieldDict[&#39;0.215&#39;] 
        represents the continuous map smoothed at a scale of 0.215 radians.
    &#39;&#39;&#39;

    #-----------------------------------------------------------------------------------------------
    
    if Verbose: 
        total_start = time.perf_counter()
        print(f&#39;\nSmoothing the density field over the given angular distance scales...\n&#39;)

    #-----------------------------------------------------------------------------------------------

    #Initializing the dictionary
    SmoothedFieldDict = {}

    #-----------------------------------------------------------------------------------------------
    
    #Looping over the nearest neighbour indices as inferred from the length of &#39;bins&#39;
    for i in range(len(bins)):

        #-------------------------------------------------------------------------------------------
        
        if Verbose: start = time.perf_counter()

        #-------------------------------------------------------------------------------------------
        
        for j, ss in enumerate(bins[i]):
            #Square bracket selects only those pixels that are not close to the mask boundaries
            #Turning verbose off to avoid too much text output
            SmoothedFieldDict[str(ss)] = \
            top_hat_smoothing_2DA(skymap, ss, Verbose=False)[query_mask==2]

        #-------------------------------------------------------------------------------------------
        
        if Verbose: 
            print(&#39;\tdistance scales for {}NN done; time taken: {:.2e} s.&#39;.format(i+1, time.perf_counter()-start))

    #-----------------------------------------------------------------------------------------------
    
    if Verbose: print(&#39;\ntotal time taken: {:.2e} s.&#39;.format(time.perf_counter()-total_start))

    return SmoothedFieldDict</code></pre>
</details>
<div class="desc"><p>Creates a dictionary containing the continuous field smoothed at various angular distance
scales.</p>
<h1 id="-">-----------------------------------------------------------------------------------------------</h1>
<h2 id="references">References</h2>
<ol>
<li>Gupta &amp; Banerjee (2024):
Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources
with k-nearest neighbour distributions, Monthly Notices of the Royal Astronomical Society,
Volume 531, Issue 4, July 2024, Pages 4619–4639, <a href="https://doi.org/10.1093/mnras/stae1424">https://doi.org/10.1093/mnras/stae1424</a></li>
</ol>
<h1 id="-_1">-----------------------------------------------------------------------------------------------</h1>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>skymap</code></strong> :&ensp;<code>float array</code></dt>
<dd>the healpy map of the continuous field that needs to be smoothed.
The values of the masked pixels, if any, should be set to hp.UNSEEN.</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>list</code> of <code>float arrays</code></dt>
<dd>list of distances for each nearest neighbour. The i^th element of the list should contain a
numpy array of the desired distances for the i^th nearest neighbour.</dd>
<dt><strong><code>query_mask</code></strong> :&ensp;<code>int array</code> of <code>same size as 'skymap'</code></dt>
<dd>array with 0, 1 and 2 indicating that the corresponding HEALPixel is outside the mask,
too close to mask boundary and sufficiently far away from the boundary, respectively.
Refer to function 'create_query' defined above for creating the query mask and see
Gupta and Banerjee (2024) for more details).</dd>
<dt><strong><code>Verbose</code></strong> :&ensp;<code>Binary</code></dt>
<dd>if set to True, the time taken to complete each step of the calculation will be printed.
Defaults to False.</dd>
</dl>
<h1 id="-_2">-----------------------------------------------------------------------------------------------</h1>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>SmoothedFieldDict</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>dictionary containing the continuous field masked within the observational footprint and
smoothed at various angular distance scales. For example, SmoothedFieldDict['0.215']
represents the continuous map smoothed at a scale of 0.215 radians.</dd>
</dl></div>
</dd>
<dt id="kNN_ASMR.HelperFunctions.HelperFunctions.kNN_excess_cross_corr"><code class="name flex">
<span>def <span class="ident">kNN_excess_cross_corr</span></span>(<span>auto_cdf_list_1, auto_cdf_list_2, joint_cdf_list, k1_k2_list=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kNN_excess_cross_corr(auto_cdf_list_1, auto_cdf_list_2, joint_cdf_list, k1_k2_list=None):

    &#39;&#39;&#39;
    Computes the excess spatial cross-correlation (Banerjee &amp; Abel 2023) between two tracers 
    (discrete or continuous) from their joint kNN distributions (&#39;joint_cdf_list&#39;) and their 
    respective kNN-CDFs (&#39;auto_cdf_list_1&#39;, &#39;auto_cdf_list_2&#39;).

    #-----------------------------------------------------------------------------------------------

    References:

        1. Banerjee &amp; Abel (2023):
        Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour 
        distributions, Monthly Notices of the Royal Astronomical Society, Volume 519, Issue 4, 
        March 2023, Pages 4856–4868, https://doi.org/10.1093/mnras/stac3813

    #-----------------------------------------------------------------------------------------------

    Parameters
    ----------

    auto_cdf_list_1: list of float arrays
        auto kNN-CDFs of the first set of tracers evaluated.
        
    auto_cdf_list_2: list of float arrays
        auto kNN-CDFs of the second set of tracers evaluated.
    
    joint_cdf_list: list of float arrays
        joint kNN distributions of the two tracer sets

    k1_k2_list: list of int tuples
        describes the kind of cross-correlations being computed. Should be None for every scenario 
        other than tracer-tracer cross-correlation, in which case it should provide the combinations
        of NN indices in the list of joint CDFs. For example, if you wish to compute the excess 
        cross correlation for the joint {1,1}, {1,2} and {2,1}NN-CDFs, then set 
            
            k1_k2_list = [(1,1), (1,2), (2,1)]

        Note that the tuples should be consistent with the &#39;joint_cdf_list&#39;. For example, if

            k1_k2_list = [(1,1), (1,2)]

        then
        
            joint_cdf_list = 

        must hold.
        Defaults to None. If None is passed for tracer-tracer cross-correlations, the correlations
        are assumed to be between the same NN indices (eg. {1,1}NN-CDF, {2,2}NN-CDF).

    #-----------------------------------------------------------------------------------------------

    Returns
    -------

    psi_list: list of float arrays
        excess spatial cross-correlation between the two tracer sets
    &#39;&#39;&#39;

    #-------------------------------------------------------------------------------------------

    psi_list = []

    #-------------------------------------------------------------------------------------------
    
    if k1_k2_list:

        #Check for consistency:
        if len(joint_cdf_list)!=len(k1_k2_list): 
            raise ValueError(&#39;Inconsistent input: shape of &#34;joint_cdf_list&#34; not consistent with that of &#34;k1_k2_list&#34;&#39;)
        for k, (k1, k2) in enumerate(k1_k2_list):
            psi_list.append(joint_cdf_list[k]/(auto_cdf_list_1[k1]*auto_cdf_list_2[k2]))

    #-------------------------------------------------------------------------------------------
    
    else:
        #Check for consistency:
        if len(joint_cdf_list)!=len(auto_cdf_list_1) or len(joint_cdf_list)!=len(auto_cdf_list_2): 
            raise ValueError(&#39;Inconsistent input: shapes not compatible with each other&#39;)
        for k in range(len(joint_cdf_list)):
            psi_list.append(joint_cdf_list[k]/(auto_cdf_list_1[k]*auto_cdf_list_2[k]))

    return psi_list</code></pre>
</details>
<div class="desc"><p>Computes the excess spatial cross-correlation (Banerjee &amp; Abel 2023) between two tracers
(discrete or continuous) from their joint kNN distributions ('joint_cdf_list') and their
respective kNN-CDFs ('auto_cdf_list_1', 'auto_cdf_list_2').</p>
<h1 id="-">-----------------------------------------------------------------------------------------------</h1>
<h2 id="references">References</h2>
<ol>
<li>Banerjee &amp; Abel (2023):
Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour
distributions, Monthly Notices of the Royal Astronomical Society, Volume 519, Issue 4,
March 2023, Pages 4856–4868, <a href="https://doi.org/10.1093/mnras/stac3813">https://doi.org/10.1093/mnras/stac3813</a></li>
</ol>
<h1 id="-_1">-----------------------------------------------------------------------------------------------</h1>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>auto_cdf_list_1</code></strong> :&ensp;<code>list</code> of <code>float arrays</code></dt>
<dd>auto kNN-CDFs of the first set of tracers evaluated.</dd>
<dt><strong><code>auto_cdf_list_2</code></strong> :&ensp;<code>list</code> of <code>float arrays</code></dt>
<dd>auto kNN-CDFs of the second set of tracers evaluated.</dd>
<dt><strong><code>joint_cdf_list</code></strong> :&ensp;<code>list</code> of <code>float arrays</code></dt>
<dd>joint kNN distributions of the two tracer sets</dd>
<dt><strong><code>k1_k2_list</code></strong> :&ensp;<code>list</code> of <code>int tuples</code></dt>
<dd>
<p>describes the kind of cross-correlations being computed. Should be None for every scenario
other than tracer-tracer cross-correlation, in which case it should provide the combinations
of NN indices in the list of joint CDFs. For example, if you wish to compute the excess
cross correlation for the joint {1,1}, {1,2} and {2,1}NN-CDFs, then set </p>
<pre><code>k1_k2_list = [(1,1), (1,2), (2,1)]
</code></pre>
<p>Note that the tuples should be consistent with the 'joint_cdf_list'. For example, if</p>
<pre><code>k1_k2_list = [(1,1), (1,2)]
</code></pre>
<p>then</p>
<pre><code>joint_cdf_list =
</code></pre>
<p>must hold.
Defaults to None. If None is passed for tracer-tracer cross-correlations, the correlations
are assumed to be between the same NN indices (eg. {1,1}NN-CDF, {2,2}NN-CDF).</p>
</dd>
</dl>
<h1 id="-_2">-----------------------------------------------------------------------------------------------</h1>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psi_list</code></strong> :&ensp;<code>list</code> of <code>float arrays</code></dt>
<dd>excess spatial cross-correlation between the two tracer sets</dd>
</dl></div>
</dd>
<dt id="kNN_ASMR.HelperFunctions.HelperFunctions.top_hat_smoothing_2DA"><code class="name flex">
<span>def <span class="ident">top_hat_smoothing_2DA</span></span>(<span>skymap, scale, Verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top_hat_smoothing_2DA(skymap, scale, Verbose=False):

    &#39;&#39;&#39;
    Smooths the given map at the given scale using the top hat window function in harmonic space.
    See Devaraju (2015) for a discussion and derivation of expressions used here.

    #-----------------------------------------------------------------------------------------------

    References:

        1. Devaraju (2015):
        Devaraju B., 2015, doctoralThesis, doi:10.18419/opus-3985, http://elib.uni-stuttgart.de/handle/11682/4002

    #-----------------------------------------------------------------------------------------------
    
    Parameters
    ----------
    
    skymap: float array
        the healpy map of the continuous field that needs to be smoothed.
        The values of the masked pixels, if any, should be set to hp.UNSEEN.

    scale: float
        angular scale (in radians) at which the field is to be smoothed.
        Please ensure scale is between 0 and 2*pi.

    Verbose: Binary
        if set to True, the time taken to complete each step of the calculation will be printed.
        Defaults to False.

    #-----------------------------------------------------------------------------------------------

    Returns
    -------

    smoothed_map_masked: float array of same size as input array &#39;skymap&#39;
        the smoothed healpy map, keeping the masked pixels of the original map masked.
    &#39;&#39;&#39;

    #-----------------------------------------------------------------------------------------------

    if Verbose: total_start_time = time.perf_counter()

    #-----------------------------------------------------------------------------------------------

    #Check all inputs are consistent with the function requirement

    if Verbose: print(&#39;Checking inputs ...&#39;)

    if scale&lt;0 or scale&gt;2*np.pi:
        raise ValueError(&#39;Invalid angular smoothing scale: please ensure 0 &lt;= scale &lt;= 2*pi.&#39;)

    if Verbose: print(&#39;\tdone.&#39;)

    #-----------------------------------------------------------------------------------------------
    
    #Getting the NSIDE of the map
    NSIDE = hp.get_nside(skymap)

    #Using the default l_max for the harmonic expansion
    l_max = 3*NSIDE-1

    #-----------------------------------------------------------------------------------------------

    #Computing the spherical harmonic expansion for the map
    if Verbose: 
        print(&#39;\nComputing the spherical harmonic expansion for the map ...&#39;)
    l_arr = np.array(range(l_max+1))                                     
    map_alm = hp.map2alm(skymap, use_pixel_weights=False, lmax=l_max)
    if Verbose: print(&#39;\tdone.&#39;)

    #-----------------------------------------------------------------------------------------------

    #Getting the legendre coefficients of the top hat window function
    if Verbose: 
        print(&#39;\nGetting the legendre coefficients of the top hat window function ...&#39;)
    bl = bl_th(l_arr, scale)
    if Verbose: print(&#39;\tdone.&#39;)

    #-----------------------------------------------------------------------------------------------

    #Getting the spherical harmonic expansion of the smoothed map
    if Verbose: 
        print(&#39;\nGetting the spherical harmonic expansion of the smoothed map ...&#39;)
    smoothed_alm = np.zeros(map_alm.shape[0], dtype = &#39;complex&#39;)    
    for l in range(l_max+1):
        for m in range(l+1):
            ind_lm = hp.Alm.getidx(l_max, l, m)
            smoothed_alm[ind_lm] = map_alm[ind_lm]*bl[l] 
    if Verbose: print(&#39;\tdone.&#39;)

    #-----------------------------------------------------------------------------------------------

    #Generating the smoothed map from the harmonic coeffients
    if Verbose: 
        print(&#39;\nGenerating the smoothed map from the harmonic coeffients ...&#39;)
    smoothed_map = hp.alm2map(smoothed_alm, nside=NSIDE)
    if Verbose: print(&#39;\tdone.&#39;)

    #-----------------------------------------------------------------------------------------------

    #If a mask is present
    smoothed_map_masked = copy.deepcopy(smoothed_map)                    
    smoothed_map_masked[skymap==hp.UNSEEN] = hp.UNSEEN

    #-----------------------------------------------------------------------------------------------

    if Verbose: print(&#39;\ntotal time taken: {:.2e} s.&#39;.format(time.perf_counter()-total_start_time))

    return smoothed_map_masked</code></pre>
</details>
<div class="desc"><p>Smooths the given map at the given scale using the top hat window function in harmonic space.
See Devaraju (2015) for a discussion and derivation of expressions used here.</p>
<h1 id="-">-----------------------------------------------------------------------------------------------</h1>
<h2 id="references">References</h2>
<ol>
<li>Devaraju (2015):
Devaraju B., 2015, doctoralThesis, doi:10.18419/opus-3985, <a href="http://elib.uni-stuttgart.de/handle/11682/4002">http://elib.uni-stuttgart.de/handle/11682/4002</a></li>
</ol>
<h1 id="-_1">-----------------------------------------------------------------------------------------------</h1>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>skymap</code></strong> :&ensp;<code>float array</code></dt>
<dd>the healpy map of the continuous field that needs to be smoothed.
The values of the masked pixels, if any, should be set to hp.UNSEEN.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>angular scale (in radians) at which the field is to be smoothed.
Please ensure scale is between 0 and 2*pi.</dd>
<dt><strong><code>Verbose</code></strong> :&ensp;<code>Binary</code></dt>
<dd>if set to True, the time taken to complete each step of the calculation will be printed.
Defaults to False.</dd>
</dl>
<h1 id="-_2">-----------------------------------------------------------------------------------------------</h1>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>smoothed_map_masked</code></strong> :&ensp;<code>float array</code> of <code>same size as input array 'skymap'</code></dt>
<dd>the smoothed healpy map, keeping the masked pixels of the original map masked.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="kNN_ASMR.HelperFunctions.HelperFunctions.bl_th" href="#kNN_ASMR.HelperFunctions.HelperFunctions.bl_th">bl_th</a></code></li>
<li><code><a title="kNN_ASMR.HelperFunctions.HelperFunctions.calc_kNN_CDF" href="#kNN_ASMR.HelperFunctions.HelperFunctions.calc_kNN_CDF">calc_kNN_CDF</a></code></li>
<li><code><a title="kNN_ASMR.HelperFunctions.HelperFunctions.cdf_vol_knn" href="#kNN_ASMR.HelperFunctions.HelperFunctions.cdf_vol_knn">cdf_vol_knn</a></code></li>
<li><code><a title="kNN_ASMR.HelperFunctions.HelperFunctions.create_query" href="#kNN_ASMR.HelperFunctions.HelperFunctions.create_query">create_query</a></code></li>
<li><code><a title="kNN_ASMR.HelperFunctions.HelperFunctions.create_smoothed_field_dict" href="#kNN_ASMR.HelperFunctions.HelperFunctions.create_smoothed_field_dict">create_smoothed_field_dict</a></code></li>
<li><code><a title="kNN_ASMR.HelperFunctions.HelperFunctions.kNN_excess_cross_corr" href="#kNN_ASMR.HelperFunctions.HelperFunctions.kNN_excess_cross_corr">kNN_excess_cross_corr</a></code></li>
<li><code><a title="kNN_ASMR.HelperFunctions.HelperFunctions.top_hat_smoothing_2DA" href="#kNN_ASMR.HelperFunctions.HelperFunctions.top_hat_smoothing_2DA">top_hat_smoothing_2DA</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
