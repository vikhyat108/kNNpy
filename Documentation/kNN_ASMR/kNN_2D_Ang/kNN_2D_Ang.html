<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>kNN_ASMR.kNN_2D_Ang.kNN_2D_Ang API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kNN_ASMR.kNN_2D_Ang.kNN_2D_Ang</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kNN_ASMR.kNN_2D_Ang.kNN_2D_Ang.TracerFieldCross2DA"><code class="name flex">
<span>def <span class="ident">TracerFieldCross2DA</span></span>(<span>kMax,<br>BinsRad,<br>MaskedQueryPosRad,<br>MaskedTracerPosRad,<br>SmoothedFieldDict,<br>FieldConstPercThreshold,<br>Verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TracerFieldCross2DA(kMax, BinsRad, MaskedQueryPosRad, MaskedTracerPosRad, SmoothedFieldDict,  FieldConstPercThreshold, Verbose=False):
    
    &#39;&#39;&#39;
    Returns the probabilities \\(P_{&gt;k}\\), \\(P_{&gt;dt}\\) and \\(P_{&gt;k,&gt;dt}\\) for \\(1 \leq k \leq\\) `kMax`, that quantify the extent of the spatial cross-correlation between the given discrete tracer positions (`MaskedTracerPosRad`) and the given continuous overdensity field (`SmoothedFieldDict`). 
        
    1. \\(P_{&gt;k}(\\theta)\\): 
        the kNN-CDF of the discrete tracers, evaluated at angular distance scale \\(\\theta\\)
                
    2. \\(P_{&gt;{\\rm dt}}(\\theta)\\): 
        the probability of the overdensity field smoothed with a top-hat filter of angular size \\(\\theta\\) exceeding the given constant percentile density threshold
                
    3. \\(P_{&gt;k, &gt;{\\rm dt}}(\\theta)\\):
        the joint probability of finding at least &#39;k&#39; tracers within a spherical cap of radius \(\\theta\\) AND the overdensity field smoothed at angular scale \\(\\theta\\) exceeding the given density threshold
                
    The excess cross-correlation (Banerjee &amp; Abel 2023)[^1] can be computed trivially from the quatities (see the &#39;HelperFunctions&#39; module for a method to do this):
        
    \\[\\psi_{k, {\\rm dt}} = P_{&gt;k, &gt;{\\rm dt}}/(P_{&gt;k} \\times P_{&gt;{\\rm dt}})\\]

    Parameters
    ----------
    kMax : int
        the number of nearest neighbours to calculate the distances to. For example, if `kMax` = 3, the first 3 nearest-neighbour distributions will be computed.
    BinsRad : list of array_like
        list of angular distances (in radians) for each nearest neighbour. The \\(i^{th}\\) element of the list should contain a numpy array of the desired distances for the \\(i^{th}\\) nearest neighbour.
    MaskedQueryPosRad : array_like of shape (n_query, 2)
        array of sky locations for the query points. The sky locations must be on a grid. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure `-np.pi/2 &lt;= declination &lt;= pi/2` and `0 &lt;= right ascension &lt;= 2*np.pi`.
    MaskedTracerPosRad : array_like of shape (n_tracer, 2)
        array of sky locations for the discrete tracers. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure `-np.pi/2 &lt;= declination &lt;= pi/2` and `0 &lt;= right ascension &lt;= 2*np.pi`.
    SmoothedFieldDict : dict
        dictionary containing the continuous field masked within the observational footprint and smoothed at various angular distance scales. For example, `SmoothedFieldDict[&#39;0.215&#39;]` represents the continuous map smoothed at a scale of 0.215 radians.
    FieldConstPercThreshold : float
        the percentile value for the constant percentile threshold to be used for the continuous field. For example, `FieldConstPercThreshold` = 75.0 represents a 75th percentile threshold.
    Verbose : bool, optional
        if set to True, the time taken to complete each step of the calculation will be printed, by default False.

    Returns
    -------
    p_gtr_k_list: list of array_like, each of shape 
                  len(`BinsRad`[k-1]) for 1 &lt;= k &lt;= `kMax`
        auto kNN-CDFs of the discrete tracers evaluated at the desired distance bins.
        
    p_gtr_dt_list: list of array_like, each of shape 
                   len(`BinsRad`[k-1]) for 1 &lt;= k &lt;= `kMax`
        continuum version of auto kNN-CDFs for the continuous field evaluated at the desired 
        distance bins.
    
    p_gtr_k_dt_list: list of array_like, each of shape 
                     len(`BinsRad`[k-1]) for 1 &lt;= k &lt;= `kMax`
        joint tracer-field nearest neighbour distributions evaluated at the desired distance bins

    Raises
    ------
    ValueError
        if the given query points are not on a two-dimensional grid.
    ValueError
        if declination of any of the query points is not in [``-np.pi/2``, ``np.pi/2``].
    ValueError
        if right ascension of any of the query points is not in [``0``, ``2*np.pi``].
    ValueError
        if declination of any of the tracer points is not in [``-np.pi/2``, ``np.pi/2``].
    ValueError
        if right ascension of any of the tracer points is not in [``0``, ``2*np.pi``].
    ValueError
        if the given tracer points are not on a two-dimensional grid.
    ValueError
        if the shape of field smoothed at a particular scale does not match the shape of the query point array.

    Notes
    -----
    Measures the angular cross-correlation between a set of discrete tracers and a continuous overdensity field using the k-nearest neighbour (kNN) formalism as defined in Banerjee &amp; Abel (2023)[^1] and Gupta &amp; Banerjee (2024)[^2].
    
    The field must already be smoothed at the desired angular distance scales using a top-hat filter (see the &#39;HelperFunctions&#39; module for help with smoothing). The smoothed fields need to be provided as a dictionary (&#39;SmoothedFieldDict&#39;), see below for further details.
    
    Currently, the algorithm requires a constant percentile overdensity threshold for the continuous field and query points to be defined on a HEALPix grid. Extentions to a constant mass threshold and poisson-sampled query points on the sky may be added in the future. 
    
    Data with associated observational footprints are supported, in which case, only tracer positions within the footprint should be provided and the field should be masked appropriately.Importantly, in this case, query points need to be within the footprint and appropriately padded from the edges of the footprint (see Gupta &amp; Banerjee (2024)[^2] for a detailed discussion). If the footprints of the tracer set and the field are different, a combined mask representing the intersection of the two footprints should be used (see the &#39;HelperFunctions&#39; module for help with masking and creating the modified query positions).

    References
    ----------
    [^1]: Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour   distributions, [Monthly Notices of the Royal Astronomical Society](https://doi.org/10.1093/mnras/stac3813), Volume 519, Issue 4, March 2023, Pages 4856–4868
        
    [^2]: Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, [Monthly Notices of the Royal Astronomical Society](https://doi.org/10.1093/mnras/stae1424), Volume 531, Issue 4, July 2024, Pages 4619–4639
    &#39;&#39;&#39;
    
    #-----------------------------------------------------------------------------------------------

    if Verbose: total_start_time = time.perf_counter()

    #-----------------------------------------------------------------------------------------------
        
    #Step 0: Check all inputs are consistent with the function requirement

    if Verbose: print(&#39;Checking inputs ...&#39;)

    if MaskedQueryPosRad.shape[1]!=2: 
        raise ValueError(&#39;Incorrect spatial dimension for query points: array containing the query point positions must be of shape (n_query, 2), where n_query is the number of query points.&#39;)

    if np.any(MaskedQueryPosRad[:, 0]&lt;-np.pi/2 or MaskedQueryPosRad[:, 0]&gt;np.pi/2):
        raise ValueError(&#39;Invalid query point position(s): please ensure -pi/2 &lt;= declination &lt;= pi/2.&#39;)

    if np.any(MaskedQueryPosRad[:, 1]&lt;0 or MaskedQueryPosRad[:, 0]&gt;2*np.pi):
        raise ValueError(&#39;Invalid query point position(s): please ensure 0 &lt;= right ascension &lt;= 2*pi.&#39;)

    if np.any(MaskedTracerPosRad[:, 0]&lt;-np.pi/2 or MaskedTracerPosRad[:, 0]&gt;np.pi/2):
        raise ValueError(&#39;Invalid tracer point position(s): please ensure -pi/2 &lt;= declination &lt;= pi/2.&#39;)

    if np.any(MaskedTracerPosRad[:, 1]&lt;0 or MaskedTracerPosRad[:, 0]&gt;2*np.pi):
        raise ValueError(&#39;Invalid tracer point position(s): please ensure 0 &lt;= right ascension &lt;= 2*pi.&#39;)

    if MaskedTracerPosRad.shape[1]!=2: 
        raise ValueError(&#39;Incorrect spatial dimension for tracers: array containing the tracer positions must be of shape (n_tracer, 2), where n_tracer is the number of tracers.&#39;)

    if Verbose: print(&#39;\tdone.&#39;)

    #-----------------------------------------------------------------------------------------------
        
    #Step 1: Calculate nearest neighbour distances of query points, and the kNN-CDFs for the discrete tracers

    if Verbose: 
        step_1_start_time = time.perf_counter()
        print(&#39;\ninitiating step 1 ...&#39;)

    #-----------------------------------------------------------------------------------------------
    
    #Building the tree
    if Verbose: 
        start_time = time.perf_counter()
        print(&#39;\n\tbuilding the tree ...&#39;)
    xtree = BallTree(MaskedTracerPosRad, metric=&#39;haversine&#39;)
    if Verbose: print(&#39;\t\tdone; time taken: {:.2e} s.&#39;.format(time.perf_counter()-start_time))

    #-----------------------------------------------------------------------------------------------
    
    #Calculating the NN distances
    if Verbose: 
        start_time = time.perf_counter()
        print(&#39;\n\tcomputing the tracer NN distances ...&#39;)
    vol, _ = xtree.query(MaskedQueryPosRad, k=kMax)
    if Verbose: print(&#39;\t\tdone; time taken: {:.2e} s.&#39;.format(time.perf_counter()-start_time))

    #-----------------------------------------------------------------------------------------------
    
    #Calculating the kNN-CDFs
    if Verbose: 
        start_time = time.perf_counter()
        print(&#39;\n\tcomputing the tracer auto-CDFs P_{&gt;k} ...&#39;)
    kList = range(1, kMax+1)
    p_gtr_k_list = calc_kNN_CDF(vol, kList, BinsRad)

    #-----------------------------------------------------------------------------------------------
    
    if Verbose: 
        print(&#39;\t\tdone; time taken: {:.2e} s.&#39;.format(time.perf_counter()-start_time))
        print(&#39;\ntime taken for step 1: {:.2e} s.&#39;.format(time.perf_counter()-step_1_start_time))
    
    #-----------------------------------------------------------------------------------------------
        
    #Steps 2: calculate the fraction of query points with nearest neighbour distance less than the angular distance and smoothened field greater than the overdensity threshold

    if Verbose: 
        step_2_start_time = time.perf_counter()
        print(&#39;\ninitiating step 2 ...&#39;)

    #-----------------------------------------------------------------------------------------------
        
    p_gtr_k_dt_list = []
    p_gtr_dt_list = []
    
    for k in range(kMax):

        if Verbose: 
            start_time = time.perf_counter()
            print(&#39;\n\tComputing P_{&gt;dt} and P_{&gt;k, dt} for k = {} ...&#39;.format(k))

        p_gtr_k_dt = np.zeros(len(BinsRad[k]))
        p_gtr_dt = np.zeros(len(BinsRad[k]))

        for i, ss in enumerate(BinsRad[k]):

            #---------------------------------------------------------------------------------------

            #Load the smoothed field
            SmoothedField = SmoothedFieldDict[str(ss)]

            #Check if the masked smoothed field is consistent with the number of query points
            if SmoothedField.shape[0]!=MaskedQueryPosRad.shape[0]:
                raise ValueError(&#39;Shape of field smoothed at scale {:.3e} rad does not match shape of query point array.&#39;.format(ss))

            #---------------------------------------------------------------------------------------
            
            #Compute the overdensity threshold            
            delta_star_ss = np.percentile(SmoothedField, FieldConstPercThreshold)    

            #---------------------------------------------------------------------------------------

            #Compute the fraction of query points satisfying the joint condition
            ind_gtr_k_dt = np.where((vol[:, k]&lt;ss)&amp;(SmoothedField&gt;delta_star_ss))
            p_gtr_k_dt[i] = len(ind_gtr_k_dt[0])/MaskedQueryPosRad.shape[0]

            #---------------------------------------------------------------------------------------

            #Compute the fraction of query points with smoothed field exceeding the overdensity threshold
            ind_gtr_dt = np.where(SmoothedField&gt;delta_star_ss)
            p_gtr_dt[i] = len(ind_gtr_dt[0])/MaskedQueryPosRad.shape[0]

        #-------------------------------------------------------------------------------------------

        p_gtr_k_dt_list.append(p_gtr_k_dt)
        p_gtr_dt_list.append(p_gtr_dt)

        #-------------------------------------------------------------------------------------------

        if Verbose: print(&#39;\t\tdone; time taken for step 2: {:.2e} s.&#39;.format(time.perf_counter()-step_2_start_time))

    #-----------------------------------------------------------------------------------------------

    if Verbose: print(&#39;\ntotal time taken: {:.2e} s.&#39;.format(time.perf_counter()-total_start_time))
    
    return p_gtr_k_list, p_gtr_dt_list, p_gtr_k_dt_list</code></pre>
</details>
<div class="desc"><p>Returns the probabilities <span><span class="MathJax_Preview">P_{&gt;k}</span><script type="math/tex">P_{>k}</script></span>, <span><span class="MathJax_Preview">P_{&gt;dt}</span><script type="math/tex">P_{>dt}</script></span> and <span><span class="MathJax_Preview">P_{&gt;k,&gt;dt}</span><script type="math/tex">P_{>k,>dt}</script></span> for <span><span class="MathJax_Preview">1 \leq k \leq</span><script type="math/tex">1 \leq k \leq</script></span> <code>kMax</code>, that quantify the extent of the spatial cross-correlation between the given discrete tracer positions (<code>MaskedTracerPosRad</code>) and the given continuous overdensity field (<code>SmoothedFieldDict</code>). </p>
<ol>
<li>
<p><span><span class="MathJax_Preview">P_{&gt;k}(\theta)</span><script type="math/tex">P_{>k}(\theta)</script></span>:
the kNN-CDF of the discrete tracers, evaluated at angular distance scale <span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span></p>
</li>
<li>
<p><span><span class="MathJax_Preview">P_{&gt;{\rm dt}}(\theta)</span><script type="math/tex">P_{>{\rm dt}}(\theta)</script></span>:
the probability of the overdensity field smoothed with a top-hat filter of angular size <span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span> exceeding the given constant percentile density threshold</p>
</li>
<li>
<p><span><span class="MathJax_Preview">P_{&gt;k, &gt;{\rm dt}}(\theta)</span><script type="math/tex">P_{>k, >{\rm dt}}(\theta)</script></span>:
the joint probability of finding at least 'k' tracers within a spherical cap of radius <span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span> AND the overdensity field smoothed at angular scale <span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span> exceeding the given density threshold</p>
</li>
</ol>
<p>The excess cross-correlation (Banerjee &amp; Abel 2023)<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup> can be computed trivially from the quatities (see the 'HelperFunctions' module for a method to do this):</p>
<p><span><span class="MathJax_Preview">\psi_{k, {\rm dt}} = P_{&gt;k, &gt;{\rm dt}}/(P_{&gt;k} \times P_{&gt;{\rm dt}})</span><script type="math/tex; mode=display">\psi_{k, {\rm dt}} = P_{>k, >{\rm dt}}/(P_{>k} \times P_{>{\rm dt}})</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kMax</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of nearest neighbours to calculate the distances to. For example, if <code>kMax</code> = 3, the first 3 nearest-neighbour distributions will be computed.</dd>
<dt><strong><code>BinsRad</code></strong> :&ensp;<code>list</code> of <code>array_like</code></dt>
<dd>list of angular distances (in radians) for each nearest neighbour. The <span><span class="MathJax_Preview">i^{th}</span><script type="math/tex">i^{th}</script></span> element of the list should contain a numpy array of the desired distances for the <span><span class="MathJax_Preview">i^{th}</span><script type="math/tex">i^{th}</script></span> nearest neighbour.</dd>
<dt><strong><code>MaskedQueryPosRad</code></strong> :&ensp;<code>array_like</code> of <code>shape (n_query, 2)</code></dt>
<dd>array of sky locations for the query points. The sky locations must be on a grid. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</dd>
<dt><strong><code>MaskedTracerPosRad</code></strong> :&ensp;<code>array_like</code> of <code>shape (n_tracer, 2)</code></dt>
<dd>array of sky locations for the discrete tracers. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</dd>
<dt><strong><code>SmoothedFieldDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary containing the continuous field masked within the observational footprint and smoothed at various angular distance scales. For example, <code>SmoothedFieldDict['0.215']</code> represents the continuous map smoothed at a scale of 0.215 radians.</dd>
<dt><strong><code>FieldConstPercThreshold</code></strong> :&ensp;<code>float</code></dt>
<dd>the percentile value for the constant percentile threshold to be used for the continuous field. For example, <code>FieldConstPercThreshold</code> = 75.0 represents a 75th percentile threshold.</dd>
<dt><strong><code>Verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if set to True, the time taken to complete each step of the calculation will be printed, by default False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>p_gtr_k_list</code></strong> :&ensp;<code>list</code> of <code>array_like, each</code> of <code>shape </code></dt>
<dd>len(<code>BinsRad</code>[k-1]) for 1 &lt;= k &lt;= <code>kMax</code>
auto kNN-CDFs of the discrete tracers evaluated at the desired distance bins.</dd>
<dt><strong><code>p_gtr_dt_list</code></strong> :&ensp;<code>list</code> of <code>array_like, each</code> of <code>shape </code></dt>
<dd>len(<code>BinsRad</code>[k-1]) for 1 &lt;= k &lt;= <code>kMax</code>
continuum version of auto kNN-CDFs for the continuous field evaluated at the desired
distance bins.</dd>
<dt><strong><code>p_gtr_k_dt_list</code></strong> :&ensp;<code>list</code> of <code>array_like, each</code> of <code>shape </code></dt>
<dd>len(<code>BinsRad</code>[k-1]) for 1 &lt;= k &lt;= <code>kMax</code>
joint tracer-field nearest neighbour distributions evaluated at the desired distance bins</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if the given query points are not on a two-dimensional grid.</dd>
<dt><code>ValueError</code></dt>
<dd>if declination of any of the query points is not in [<code>-np.pi/2</code>, <code>np.pi/2</code>].</dd>
<dt><code>ValueError</code></dt>
<dd>if right ascension of any of the query points is not in [<code>0</code>, <code>2*np.pi</code>].</dd>
<dt><code>ValueError</code></dt>
<dd>if declination of any of the tracer points is not in [<code>-np.pi/2</code>, <code>np.pi/2</code>].</dd>
<dt><code>ValueError</code></dt>
<dd>if right ascension of any of the tracer points is not in [<code>0</code>, <code>2*np.pi</code>].</dd>
<dt><code>ValueError</code></dt>
<dd>if the given tracer points are not on a two-dimensional grid.</dd>
<dt><code>ValueError</code></dt>
<dd>if the shape of field smoothed at a particular scale does not match the shape of the query point array.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Measures the angular cross-correlation between a set of discrete tracers and a continuous overdensity field using the k-nearest neighbour (kNN) formalism as defined in Banerjee &amp; Abel (2023)<sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">1</a></sup> and Gupta &amp; Banerjee (2024)<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>.</p>
<p>The field must already be smoothed at the desired angular distance scales using a top-hat filter (see the 'HelperFunctions' module for help with smoothing). The smoothed fields need to be provided as a dictionary ('SmoothedFieldDict'), see below for further details.</p>
<p>Currently, the algorithm requires a constant percentile overdensity threshold for the continuous field and query points to be defined on a HEALPix grid. Extentions to a constant mass threshold and poisson-sampled query points on the sky may be added in the future. </p>
<p>Data with associated observational footprints are supported, in which case, only tracer positions within the footprint should be provided and the field should be masked appropriately.Importantly, in this case, query points need to be within the footprint and appropriately padded from the edges of the footprint (see Gupta &amp; Banerjee (2024)<sup id="fnref2:2"><a class="footnote-ref" href="#fn:2">2</a></sup> for a detailed discussion). If the footprints of the tracer set and the field are different, a combined mask representing the intersection of the two footprints should be used (see the 'HelperFunctions' module for help with masking and creating the modified query positions).</p>
<h2 id="references">References</h2>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour
distributions, <a href="https://doi.org/10.1093/mnras/stac3813">Monthly Notices of the Royal Astronomical Society</a>, Volume 519, Issue 4, March 2023, Pages 4856–4868&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href="https://doi.org/10.1093/mnras/stae1424">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619–4639&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="kNN_ASMR.kNN_2D_Ang.kNN_2D_Ang.TracerFieldCross2DA" href="#kNN_ASMR.kNN_2D_Ang.kNN_2D_Ang.TracerFieldCross2DA">TracerFieldCross2DA</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
