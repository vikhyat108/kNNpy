window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "kNNpy", "modulename": "kNNpy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.Auxiliary", "modulename": "kNNpy.Auxiliary", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.Auxiliary.Fisher", "modulename": "kNNpy.Auxiliary.Fisher", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.Auxiliary.Fisher.constructingFishermatrix", "modulename": "kNNpy.Auxiliary.Fisher", "qualname": "constructingFishermatrix", "kind": "function", "doc": "<p>Constructs the Fisher matrix from data vectors and a covariance matrix.</p>\n\n<p>Parameters:\ndata_vectors (list of numpy arrays): The data vectors for which the Fisher matrix is to be constructed. The ith element is an array containing two vectors:\n    - The first vector corresponds to the simulation for parameter p.\n    - The second vector corresponds to the simulation for parameter m OR The second vector corresponds to the simulation for fiducial parameters.\n    Also, if n_params_p!=0, all such parameters, must necessarily come after the parameters with both simulations for p and m.\ncovariance_matrix (numpy array): The covariance matrix associated with the data vectors.\nn_params_p_m (int): The number of parameters with both simulations for p and m.\nn_params_p (int): The number of parameters with just simulations for p.\ndtheta (list of float): The parameter step sizes for the derivatives. Also, if n_params_p!=0, all such parameters, must necessarily come after the parameters\nwith both simulations for p and m.\nn (int): The number of realizations.</p>\n\n<p>Returns:\nnumpy array: The constructed Fisher matrix. #Give the expression</p>\n\n<p>Raises ValueError:\n-If the length of data_vectors are not of equal length\n-If the covariance matrix is not square or does not match the length of data_vectors</p>\n\n<ul>\n<li>If length of dtheta and n_params_p_m + n_params_p do not match</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_vectors</span>, </span><span class=\"param\"><span class=\"n\">covariance_matrix</span>, </span><span class=\"param\"><span class=\"n\">dtheta</span>, </span><span class=\"param\"><span class=\"n\">n_params_p_m</span>, </span><span class=\"param\"><span class=\"n\">n_params_p</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.Auxiliary.PeakStatistics", "modulename": "kNNpy.Auxiliary.PeakStatistics", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.Auxiliary.PeakStatistics.PeakCurves", "modulename": "kNNpy.Auxiliary.PeakStatistics", "qualname": "PeakCurves", "kind": "function", "doc": "<p>Gives the peak curves for the given cosmologies' square (over)density fields.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>DensityFields</strong> (float array of shape ''(nCosmo, NofRealizations, XdfDim, YdfDim)''):\n4D Array of the 2D (over)density fields of the various cosmologies to be compared. The array should of shape (nCosmo, NofRealizations, XdfDim, YdfDim) \nwhere 'nCosmo' is the number of cosmologies to be compared, 'NofRealizations' is the number of realizations of each input cosmology \n(NofRealizations &gt;= Nreals), and 'XdfDim' and 'YdfDim' are the dimensions of the 2D density fields in pixels.\nExample: np.array(DensityFields).shape = (3, 10, 512, 512) - 3 cosmologies containing 10 realisations each of (512x512) pixel 2D density fields.</li>\n<li><strong>Nreals</strong> (int):\nNumber of realisations of the density fields to be used for the peak curves' statistics. Naturally, cannot be larger than the inherent number \nof realisations of the 2D density fields contained within the (.npy) data files input, i.e. in the above example, Nreals &lt;=10. Any non-int values \nare type-cast to int.</li>\n<li><strong>MaxThreshold</strong> (float):\nMaximum overdensity threshold for which the peak values are to be plotted.</li>\n<li><strong>Nthresh</strong> (int):\nNumber of overdensity threshold (X-axis) values to be computed in the closed interval [-1,MaxThreshold]. Any non-int values are type-cast to int.</li>\n<li><strong>Type: int</strong> (0 or 1, optional):\nType of peak curve to be plotted - 0 for raw peak curve plot; 1 for peak curves normalized by the first input cosmology's peak curve.</li>\n<li><strong>Plot: int</strong> (0 or 1, optional):\n1 to plot the output and return results, 0 to skip plotting and only return results. Any values other than 1 will skip plotting.</li>\n<li><strong>LogScale: int</strong> (0 or 1, optional):\n1 to plot the peak curves on log Y-axis, 0 to not use log Y-axis. Any values other than 1 will not output the log scale.</li>\n<li><strong>CosmoLabels</strong> (str array of shape ''(nCosmo)''):\nList of the names/labels to be assigned to the respective input cosmologies. Must have length equal to the number of cosmologies input ('nCosmo').\nExample: ['CDM', 'SIDM', 'FDM']</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>thresh, tmean, tstddev</strong> (3 numpy arrays containing the threshold values, mean peak values and std. dev. of the peak values):\nFor (Type = 0): Peak curve plot of the various input comologies' density fields.\nFor (Type = 1): Peak curve plot of the various input comologies' density fields normalized by the first input cosmology's density field.\nIn both cases, the threshold values array (X-axis, 1D) 'thresh', the peaks array (Y-axis, 2D) 'tmean' containing the number of peaks corresponding to \nthe thresholds array for each input cosmology and their corresponding standard deviations (error, 2D) 'tstddev' are also returned.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If 'Type' is not 0 or 1.</li>\n<li><strong>ValueError</strong>: If 'Nreals' is lesser than 1.</li>\n<li><strong>ValueError</strong>: If 'MaxThreshold' is lesser than or equal to (-1).</li>\n<li><strong>ValueError</strong>: If the plot needs to be output and the number of labels ('CosmoLabels') is not equal to the number of input cosmologies.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">DensityFields</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">Nreals</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">MaxThreshold</span><span class=\"o\">=</span><span class=\"mi\">16</span>,</span><span class=\"param\">\t<span class=\"n\">Nthresh</span><span class=\"o\">=</span><span class=\"mi\">101</span>,</span><span class=\"param\">\t<span class=\"n\">Type</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">Plot</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">LogScale</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">CosmoLabels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;null&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.Auxiliary.PeakStatistics.spherical_peaks", "modulename": "kNNpy.Auxiliary.PeakStatistics", "qualname": "spherical_peaks", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">denslice</span>, </span><span class=\"param\"><span class=\"n\">MaxThreshold</span>, </span><span class=\"param\"><span class=\"n\">Nthresh</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.Auxiliary.PeakStatistics.PeakCurves_Healpix", "modulename": "kNNpy.Auxiliary.PeakStatistics", "qualname": "PeakCurves_Healpix", "kind": "function", "doc": "<p>Gives the peak curves for the given cosmologies' square (over)density fields.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>DensityFields</strong> (float array of shape ''(nCosmo, NofRealizations, nPixels)''):\n3D Array of the healpix (over)density fields of the various cosmologies to be compared. The array should of shape (nCosmo, NofRealizations, nPixels) \nwhere 'nCosmo' is the number of cosmologies to be compared, 'NofRealizations' is the number of realizations of each input cosmology \n(NofRealizations &gt;= Nreals), and 'nPixels' is the number of pixels in the healpix projected (over)density field such that [nPixels = 12<em>res</em>res], \nwhere 'res' is the resolution of the healpix map.\nExample: np.array(DensityFields).shape = (3, 10, 512, 512) - 3 cosmologies containing 10 realisations each of (512x512) pixel 2D density fields.</li>\n<li><strong>Nreals</strong> (int):\nNumber of realisations of the density fields to be used for the peak curves' statistics. Naturally, cannot be larger than the inherent number \nof realisations of the 2D density fields contained within the (.npy) data files input, i.e. in the above example, Nreals &lt;=10. Any non-int values \nare type-cast to int.</li>\n<li><strong>MaxThreshold</strong> (float):\nMaximum overdensity threshold for which the peak values are to be plotted.</li>\n<li><strong>Nthresh</strong> (int):\nNumber of overdensity threshold (X-axis) values to be computed in the closed interval [-1,MaxThreshold]. Any non-int values are type-cast to int.</li>\n<li><strong>Type: int</strong> (0 or 1, optional):\nType of peak curve to be plotted - 0 for raw peak curve plot; 1 for peak curves normalized by the first input cosmology's peak curve.</li>\n<li><strong>Plot: int</strong> (0 or 1, optional):\n1 to plot the output and return results, 0 to skip plotting and only return results. Any values other than 1 will skip plotting.</li>\n<li><strong>LogScale: int</strong> (0 or 1, optional):\n1 to plot the peak curves on log Y-axis, 0 to not use log Y-axis. Any values other than 1 will not output the log scale.</li>\n<li><strong>CosmoLabels</strong> (str array of shape ''(nCosmo)''):\nList of the names/labels to be assigned to the respective input cosmologies. Must have length equal to the number of cosmologies input ('nCosmo').\nExample: ['CDM', 'SIDM', 'FDM']</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>thresh, tmean, tstddev</strong> (3 numpy arrays containing the threshold values, mean peak values and std. dev. of the peak values):\nFor (Type = 0): Peak curve plot of the various input comologies' density fields.\nFor (Type = 1): Peak curve plot of the various input comologies' density fields normalized by the first input cosmology's density field.\nIn both cases, the threshold values array (X-axis, 1D) 'thresh', the peaks array (Y-axis, 2D) 'tmean' containing the number of peaks corresponding\nto the thresholds array for each input cosmology and their corresponding standard deviations (error, 2D) 'tstddev' are also returned.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If 'Type' is not 0 or 1.</li>\n<li><strong>ValueError</strong>: If 'Nreals' is lesser than 1.</li>\n<li><strong>ValueError</strong>: If 'MaxThreshold' is lesser than or equal to (-1).</li>\n<li><strong>ValueError</strong>: If the plot needs to be output and the number of labels ('CosmoLabels') is not equal to the number of input cosmologies.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">DensityFields</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">Nreals</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">MaxThreshold</span><span class=\"o\">=</span><span class=\"mi\">16</span>,</span><span class=\"param\">\t<span class=\"n\">Nthresh</span><span class=\"o\">=</span><span class=\"mi\">101</span>,</span><span class=\"param\">\t<span class=\"n\">Type</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">Plot</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">LogScale</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">CosmoLabels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;null&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.Auxiliary.TPCF", "modulename": "kNNpy.Auxiliary.TPCF", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.Auxiliary.TPCF.3DTPCF_Tracer-Field", "modulename": "kNNpy.Auxiliary.TPCF.3DTPCF_Tracer-Field", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.Auxiliary.TPCF.3DTPCF_Tracer-Field.CrossCorr2pt", "modulename": "kNNpy.Auxiliary.TPCF.3DTPCF_Tracer-Field", "qualname": "CrossCorr2pt", "kind": "function", "doc": "<p>Calculates the Two-point Cross-correlation function between a set of tracers and a field. The interpolation can only be done using the \nCIC-mass assignment scheme.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>boxsize</strong> (float):\nThe length (in Mpc/h) of the cubic box containing the tracers and the field</li>\n<li><strong>bins</strong> (float array of shape (m,)):\nSet of m radial distances at which the 2PCF will be computed</li>\n<li><strong>QueryPos</strong> (float array of shape (n_query,3) where n_query is the number of query points):\n3D positions of the random query points inside the box, given in Cartesian coordinates (x, y, z) within the range         [0, boxsize]</li>\n<li><strong>TracerPos</strong> (float array of shape (n_pos, 3) where n_pos is the number of discrete tracers):\n3D positions of the n tracers (e.g., galaxies) inside the box, given in Cartesian coordinates (x, y, z) within the range         [0, boxsize]</li>\n<li><strong>delta</strong> (float array of shape (ngrid, ngrid, ngrid)):\nSmoothed overdensity field defined on a uniform grid with ngrid\u00b3 points</li>\n<li><strong>thickness</strong> (float, optional):\nthe thickness of the shell used for smoothing. Only use this parameter when 'Shell' filter is used. The smoothing is done using a shell with inner radius R-thickness/2 and outer radius R+thickness/2.</li>\n<li><strong>R</strong> (float, optional):\nradial scale (in Mpc/h) at which the field is to be smoothed. Only use this parameter for real space smoothing.</li>\n<li><strong>kmin</strong> (float, optional):\nthe minimum value of the wavenumber. Only use this parameter when 'Top-Hat-k' filter is used.</li>\n<li><strong>kmax</strong> (float, optional):\nthe maximum value of the wavenumber. Only use this parameter when 'Top-Hat-k' filter is used.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to True, the time taken to complete each step of the calculation will be printed, by default False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xi</strong> (float array of shape (m,)):\nThe 2-point cross-correlation function (2PCF) between the tracer positions and the field, computed at each of the m radial bins.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the given query points are not on a three-dimensional grid.</li>\n<li><strong>ValueError</strong>: if x,y, or z coordinate of any of the query points is not in <code>(0, boxsize)</code>.</li>\n<li><strong>ValueError</strong>: if x,y, or z coordinate of any of the tracer points is not in <code>(0, boxsize)</code>..</li>\n<li><strong>ValueError</strong>: if the given tracer points are not on a three-dimensional grid.</li>\n<li><strong>ValueError</strong>: if the given field is not a cubical three-dimensional array.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">boxsize</span>,</span><span class=\"param\">\t<span class=\"n\">bins</span>,</span><span class=\"param\">\t<span class=\"n\">QueryPos</span>,</span><span class=\"param\">\t<span class=\"n\">TracerPos</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span>,</span><span class=\"param\">\t<span class=\"n\">thickness</span>,</span><span class=\"param\">\t<span class=\"n\">R</span>,</span><span class=\"param\">\t<span class=\"n\">kmin</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kmax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.Auxiliary.TPCF.TracerField2DA", "modulename": "kNNpy.Auxiliary.TPCF.TracerField2DA", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.Auxiliary.TPCF.TracerField2DA.CorrelationFunction", "modulename": "kNNpy.Auxiliary.TPCF.TracerField2DA", "qualname": "CorrelationFunction", "kind": "function", "doc": "<p>Computes the angular two-point cross-correlation function between the given set of discrete tracers (<code>MaskedTracerPosRad</code>) and the given continuous overdensity field (<code>FieldSkymap</code>) at the given angular distance scales (<code>BinsRad</code>).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>BinsRad</strong> (list of numpy float array):\narray of angular distances (in radians) to compute the cross-correlation function at</li>\n<li><strong>MaskedTracerPosRad</strong> (numpy float array of shape <code>(n_tracer, 2)</code>):\narray of sky locations for the discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>FieldSkymap</strong> (numpy float array):\nthe healpy map of the continuous field. The values of the masked pixels, if any, should be set to <code>hp.UNSEEN</code>.</li>\n<li><strong>NR_ND</strong> (int):\nratio of number of randoms to number of data points used in the 2PCF calculation to remove biases caused by the presence of an observational mask, by default <code>10</code>. This is similar to the ratio of number of randoms to number data points used in the usual Landy-Szalay estimator of the 2PCF<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup>. See notes for a more detailed explanation of this parameter and how to set it appropriately.</li>\n<li><strong>ReturnSmoothedDict</strong> (bool, optional):\nif set to <code>True</code>, the dictionary containing the continuous field masked within the observational footprint, and smoothed at the provided angular distance scales, will be returned along with the nearest-neighbour measurements, by default <code>False</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>w_theta</strong> (numpy float array of shape <code>(len(Bins)-1, )</code>):\ntracer-field two-point cross-correlation function evaluated at the desired distance bins. Note that the 2PCF can't be estimated at the last bin due to the nature of the algorithm (refer to notes for details).</li>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field masked within the observational footprint and smoothed at the provided angular distance scales, returned only if <code>ReturnSmoothedDict</code> is <code>True</code>. For example, <code>SmoothedFieldDict['0.215']</code> represents the continuous map smoothed at a scale of 0.215 radians.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if declination of any of the tracer points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the tracer points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if the given tracer points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if the <code>NR_ND</code> is not an integer.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.Auxilliary.TPCF.TracerField2DA.CorrelationFunction_DataVector</code>:  computes a data vector of tracer-field two-point cross-correlations in 2D for multiple realisations of the tracer set.<br />\n<code>kNNpy.Auxilliary.TPCF.3DTPCF_Tracer-Field.CrossCorr2pt</code>:  computes tracer-field two-point cross-correlations in 3D.<br />\n<code>kNNpy.kNN_2D_Ang.TracerFieldCross2DA</code>:  computes 2D angular tracer-field cross-correlations using the $k$NN formalism.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Measures the angular two-point cross-correlation function (2pcf) between a set of discrete tracers and a continuous overdensity field using the spherical band-averaging method, as described in Gupta (2024)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">2</a></sup>. This is a generalisation of the spherical shell-averaging method described in Banerjee &amp; Abel (2023)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">3</a></sup>.</p>\n\n<p>Data with associated observational footprints are supported, in which case, only tracer positions within the footprint should be provided and the field should be masked appropriately. If the footprints of the tracer set and the field are different, a combined mask representing the intersection of the two footprints should be used. The field at the masked pixels is set to 0 (which is the mean value of an overdensity field) for the purposes of the 2PCF computation to prevent any biases due to the mask.</p>\n\n<p><enter description for the NR_ND parameter>\n<enter description of algorithm and why the 2PCF can't be estimated at the last bin></p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Kaustubh Rajesh Gupta, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, MS Thesis, Indian Institute of Science Education and Research Pune <a href=\"http://dr.iiserpune.ac.in:8080/xmlui/handle/123456789/8819\">Digital Repository</a>&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-1\">\n<p>Kaustubh Rajesh Gupta, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, MS Thesis, Indian Institute of Science Education and Research Pune <a href=\"http://dr.iiserpune.ac.in:8080/xmlui/handle/123456789/8819\">Digital Repository</a>&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 2 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour   distributions, <a href=\"https://doi.org/10.1093/mnras/stac3813\">Monthly Notices of the Royal Astronomical Society</a>, Volume 519, Issue 4, March 2023, Pages 4856\u20134868&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 3 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosRad</span>,</span><span class=\"param\">\t<span class=\"n\">FieldSkymap</span>,</span><span class=\"param\">\t<span class=\"n\">NR_ND</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">ReturnSmoothedDict</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.Auxiliary.TPCF.TracerField2DA.CorrelationFunction_DataVector", "modulename": "kNNpy.Auxiliary.TPCF.TracerField2DA", "qualname": "CorrelationFunction_DataVector", "kind": "function", "doc": "<p>Returns a 'data vector' of the angular two-point cross-correlation function between multiple realisations of the given set of discrete tracers (<code>MaskedTracerPosVectorRad</code>) and a single realisation of the given continuous overdensity field (<code>FieldSkymap</code>) at the given angular distance scales (<code>BinsRad</code>). Please refer to notes to understand why this might be useful.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>BinsRad</strong> (list of numpy float array):\narray of angular distances (in radians) to compute the cross-correlation function at</li>\n<li><strong>MaskedTracerPosVectorRad</strong> (numpy float array of shape <code>(n_realisations, n_tracer, 2)</code>):\narray of sky locations for the first set of discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>FieldSkymap</strong> (numpy float array):\nthe healpy map of the continuous field. The values of the masked pixels, if any, should be set to <code>hp.UNSEEN</code>.</li>\n<li><strong>NR_ND</strong> (int):\nratio of number of randoms to number of data points used in the 2PCF calculation to remove biases caused by the presence of an observational mask, by default <code>10</code>. This is similar to the ratio of number of randoms to number data points used in the usual Landy-Szalay estimator of the 2PCF<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup>. See notes for a more detailed explanation of this parameter and how to set it appropriately.</li>\n<li><strong>ReturnSmoothedDict</strong> (bool, optional):\nif set to <code>True</code>, the dictionary containing the continuous field masked within the observational footprint, and smoothed at the provided angular distance scales, will be returned along with the nearest-neighbour measurements, by default <code>False</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>w_theta_vector</strong> (numpy float array of shape <code>(n_realisations, len(BinsRad)-1)</code>):\ndata vector containing the tracer-field two-point cross-correlation function for multiple realisations of the discrete tracer set evaluated at the desired distance bins. Note that the 2PCF can't be estimated at the last bin due to the nature of the algorithm (refer to notes for details).</li>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field masked within the observational footprint and smoothed at the provided angular distance scales, returned only if <code>ReturnSmoothedDict</code> is <code>True</code>. For example, <code>SmoothedFieldDict['0.215']</code> represents the continuous map smoothed at a scale of 0.215 radians.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if declination of any of the tracer points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the tracer points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if the given tracer points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if the <code>NR_ND</code> is not an integer.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.Auxilliary.TPCF.TracerField2DA.CorrelationFunction</code>:  computes tracer-field two-point cross-correlations in 2D for a single realisation of the tracer set.<br />\n<code>kNNpy.Auxilliary.TPCF.3DTPCF_Tracer-Field.CrossCorr2pt</code>:  computes tracer-field two-point cross-correlations in 3D.<br />\n<code>kNNpy.kNN_2D_Ang.TracerFieldCross2DA_DataVector</code>:  computes a data vector of 2D angular tracer-field cross-correlations for multiple tracer realisations using the $k$NN formalism.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Please refer to the documentation of kNNpy.Auxilliary.TPCF.TracerFieldCross2DA.CorrelationFunction for important usage notes that also apply to this function and references. <Explain why cross-correlating multiple realisations of tracer with single realisation of field might be useful></p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Kaustubh Rajesh Gupta, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, MS Thesis, Indian Institute of Science Education and Research Pune <a href=\"http://dr.iiserpune.ac.in:8080/xmlui/handle/123456789/8819\">Digital Repository</a>&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosVectorRad</span>,</span><span class=\"param\">\t<span class=\"n\">FieldSkymap</span>,</span><span class=\"param\">\t<span class=\"n\">NR_ND</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">ReturnSmoothedDict</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions", "modulename": "kNNpy.HelperFunctions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.HelperFunctions.cdf_vol_knn", "modulename": "kNNpy.HelperFunctions", "qualname": "cdf_vol_knn", "kind": "function", "doc": "<p>Returns interpolating functions for empirical CDFs of the given $k$-nearest neighbour distances.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vol</strong> (numpy float array of shape <code>(n_query, n_kNN)</code>):\nSorted array of nearest neighbour distances, where 'n_query' is the number of query points and 'n_kNN' is the number of nearest neighbours queried.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>cdf</strong> (list of function objects):\nlist of interpolated empirical CDF functions that can be evaluated at desired distance bins.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions.calc_kNN_CDF", "modulename": "kNNpy.HelperFunctions", "qualname": "calc_kNN_CDF", "kind": "function", "doc": "<p>Returns the kNN-CDFs for the given nearest-neighbour distances, evaluated at the given distance bins.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vol</strong> (numpy float array of shape <code>(n_query, n_kNN)</code>):\n2D array containing sorted 1D arrays of nearest-neighbour distances, where 'n_query' is the number of query points and 'n_kNN' is the number of nearest-neighbours queried. <code>vol[:, i]</code> should be the array with the sorted $k_i^{th}$ nearest-neighbour distances.</li>\n<li><strong>bins</strong> (list of numpy float array):\nlist of distance scale arrays at which the CDFs need to be evaluated (units must be same as in <code>vol</code>).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>data</strong> (list of numpy float array):\nkNN-CDFs evaluated at the desired distance bins. <code>data[i]</code> is the $k_i$NN-CDF if <code>vol[:, i]</code> containts the $k_i^{th}$ nearest-neigbour distances.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vol</span>, </span><span class=\"param\"><span class=\"n\">bins</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions.create_query_3D", "modulename": "kNNpy.HelperFunctions", "qualname": "create_query_3D", "kind": "function", "doc": "<p>Generates an array of query points; can be either randomly drawn from a uniform distribution defined over the box or put on a uniform grid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>query_type</strong> ({'grid', 'random'}, str):\nthe type of query points to be generated; should be 'grid' for query points defined on a uniform grid and 'random' for query points drawn from a uniform random distribution.</li>\n<li><strong>query_grid</strong> (int):\nthe 1D size of the query points array; the total number of query points generated will be <code>query_grid**3</code>.</li>\n<li><strong>BoxSize</strong> (float):\nthe size of the 3D box of the input density field, in Mpc/h. Must be a positive real number, and must not be <code>np.inf</code> or <code>np.nan</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>query_pos</strong> (numpy float array of shape <code>(query_grid**3, 3)</code>):\narray of query point positions. For each query point in the array, the first, second and third entries are the x, y and z coordinates respectively, in Mpc/h.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if <code>BoxSize</code> is not a positive real number less than infinity.</li>\n<li><strong>ValueError</strong>: if an unknown query type is provided.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.HelperFunctions.create_query_2DA</code>:  generates query points in 2D angular coordinates.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">query_type</span>, </span><span class=\"param\"><span class=\"n\">query_grid</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions.smoothing_3D", "modulename": "kNNpy.HelperFunctions", "qualname": "smoothing_3D", "kind": "function", "doc": "<p>Smooths the given map at the given scale using a window function of choice in real or k-space. </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>field</strong> (numpy float array):\nthe 3D array of the continuous field that needs to be smoothed.</li>\n<li><strong>Filter</strong> (string):\nthe filter to be used for smoothing. 'Top-Hat', 'Gaussian', 'Shell' are for real space, and 'Top-Hat-k' is a top-hat filter in k-space.</li>\n<li><strong>grid</strong> (int):\nthe grid size of the input density field, which should be field.shape[0] assuming a cubical box.</li>\n<li><strong>BoxSize</strong> (float):\nthe size of the 3D box of the input density field, in Mpc/h.</li>\n<li><strong>R</strong> (float, optional):\nradial scale (in Mpc/h) at which the field is to be smoothed. Only use this parameter for real space smoothing.</li>\n<li><strong>kmin</strong> (float, optional):\nthe minimum value of the wavenumber. Only use this parameter when 'Top-Hat-k' filter is used.</li>\n<li><strong>kmax</strong> (float, optional):\nthe maximum value of the wavenumber. Only use this parameter when 'Top-Hat-k' filter is used.</li>\n<li><strong>thickness</strong> (float, optional):\nthe thickness of the shell used for smoothing. Only use this parameter when 'Shell' filter is used. The smoothing is done using a shell with inner radius R-thickness/2 and outer radius R+thickness/2.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to True, the time taken to complete each step of the calculation will be printed, by default False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>smoothed_field</strong> (numpy float array of shape field.shape):\nthe smoothed field.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If required parameters (like R, kmin, kmax, or thickness) are missing for the specified filter type.</li>\n<li><strong>ValueError</strong>: If the input field dimensions do not form a cubical box.</li>\n<li><strong>ValueError</strong>: If the grid size does not match the field dimensions.</li>\n<li><strong>ValueError</strong>: If an unknown filter name is provided.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For real-space filters ('Top-Hat', 'Gaussian', 'Shell'), the radial scale R must be specified.</li>\n<li>For the 'Shell' filter, thickness must also be specified.</li>\n<li>For the 'Top-Hat-k' filter in Fourier space, kmin and kmax must be specified, while R and thickness are ignored.</li>\n<li>Any unused parameters will trigger warnings but not stop execution.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">field</span>,</span><span class=\"param\">\t<span class=\"n\">Filter</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span>,</span><span class=\"param\">\t<span class=\"n\">BoxSize</span>,</span><span class=\"param\">\t<span class=\"n\">R</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kmin</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kmax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">thickness</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions.create_smoothed_field_dict_3D", "modulename": "kNNpy.HelperFunctions", "qualname": "create_smoothed_field_dict_3D", "kind": "function", "doc": "<p>Creates a dictionary containing the continuous field smoothed at various radial distance scales.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>field</strong> (numpy float array):\nthe 3D array of the continuous field that needs to be smoothed.</li>\n<li><strong>Filter</strong> (string):\nthe filter to be used for smoothing. Valid filter types are: 'Top-Hat', 'Gaussian', 'Shell'.</li>\n<li><strong>grid</strong> (int):\nthe grid size of the input density field, which should be field.shape[0] assuming a cubical box.</li>\n<li><strong>BoxSize</strong> (float):\nthe size of the 3D box of the input density field, in Mpc/h.</li>\n<li><strong>bins</strong> (list of numpy float array):\nlist of distances for each nearest neighbour. The $i^{th}$ element of the list should contain a numpy array of the desired distance scales for the $k_i^{th}$ nearest neighbour.</li>\n<li><strong>thickness</strong> (float, optional):\nthe thickness of the shell used for smoothing. Only use this parameter when 'Shell' filter is used. The smoothing is done using a shell with inner radius R-thickness/2 and outer radius R+thickness/2.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to True, the time taken to complete each step of the calculation will be printed, by default False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field smoothed at various radial distance scales. For example, <code>SmoothedFieldDict['50.0']</code>  represents the continuous map smoothed at a scale of 50 Mpc/h.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If required parameters (like bins or thickness) are missing for the specified filter type.</li>\n<li><strong>ValueError</strong>: If the input field dimensions do not form a cubical box.</li>\n<li><strong>ValueError</strong>: If the grid size does not match the field dimensions.</li>\n<li><strong>ValueError</strong>: If an unknown filter name is provided.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>This function only works for the real space filters, so 'Top-Hat-k' is not a valid filter for this function.</li>\n<li>For the 'Shell' filter, thickness must be specified.</li>\n<li>Any unused parameters will trigger warnings but not stop execution.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">field</span>, </span><span class=\"param\"><span class=\"n\">Filter</span>, </span><span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span>, </span><span class=\"param\"><span class=\"n\">bins</span>, </span><span class=\"param\"><span class=\"n\">thickness</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions.CIC_3D_Interp", "modulename": "kNNpy.HelperFunctions", "qualname": "CIC_3D_Interp", "kind": "function", "doc": "<p>Interpolates a 3D field onto particle positions using Cloud-In-Cell (CIC) interpolation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>field</strong> (numpy.ndarray of shape <code>(Ng, Ng, Ng)</code>):\nThe 3D scalar field defined on a cubic grid with resolution 'Ng^3'.</li>\n<li><strong>pos</strong> (numpy.ndarray of shape <code>(Np, 3)</code>):\nThe positions of 'Np' particles. The columns represent x, y, and z coordinates. Units in Mpc/h</li>\n<li><strong>Boxsize</strong> (float):\nThe side length of the cubic volume in the same units as <code>pos</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fieldI</strong> (numpy.ndarray of shape <code>(Np,)</code>):\nThe interpolated field values at the given particle positions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pos</span>, </span><span class=\"param\"><span class=\"n\">field</span>, </span><span class=\"param\"><span class=\"n\">Boxsize</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions.kNN_excess_cross_corr", "modulename": "kNNpy.HelperFunctions", "qualname": "kNN_excess_cross_corr", "kind": "function", "doc": "<p>Computes the excess spatial cross-correlation (Banerjee &amp; Abel 2023)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> between two tracers (discrete or continuous) from their joint kNN distributions (<code>joint_cdf_list</code>) and their respective kNN-CDFs (<code>auto_cdf_list_1</code>, <code>auto_cdf_list_2</code>).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>auto_cdf_list_1</strong> (list of numpy float array):\nauto kNN-CDFs of the first set of tracers. If <code>k1_k2_list</code> is not <code>None</code>, The $i^{th}$ element should be the $k_1^i$NN-CDF if the $i^{th}$ element of <code>k1_k2_list</code> is ($k_1^i$, $k_2^i$).</li>\n<li><strong>auto_cdf_list_2</strong> (list of numpy float array):\nauto kNN-CDFs of the second set of tracers. If <code>k1_k2_list</code> is not <code>None</code>, The $i^{th}$ element should be the $k_2^i$NN-CDF if where the $i^{th}$ element of <code>k1_k2_list</code> is ($k_1^i$, $k_2^i$).</li>\n<li><strong>joint_cdf_list</strong> (list of numpy float array):\njoint kNN distributions of the two tracer sets. If <code>k1_k2_list</code> is not <code>None</code>, The $i^{th}$ element should be the joint {$k_1^i$, $k_2^i$}NN-CDF, where the $i^{th}$ element of <code>k1_k2_list</code> is ($k_1^i$, $k_2^i$).</li>\n<li><strong>k1_k2_list</strong> (list of int tuples):\ndescribes the kind of cross-correlations being computed (see notes for more details), by default <code>None</code>. Should be not None only if dealing with tracer-tracer cross-correlations</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>psi_list</strong> (list of numpy float array):\nexcess spatial cross-correlation between the two tracer sets.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if <code>k1_k2_list</code> is not <code>None</code> and <code>len(joint_cdf_list)!=len(k1_k2_list)</code></li>\n<li><strong>ValueError</strong>: if <code>k1_k2_list</code> is <code>None</code> and <code>len(joint_cdf_list)!=len(auto_cdf_list_1) or len(joint_cdf_list)!=len(auto_cdf_list_2)</code></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The parameter <code>k1_k2_list</code> describes the kind of cross-correlations being computed. It should be set to <code>None</code> for every scenario other than tracer-tracer cross-correlation, in which case it should provide the combinations of NN indices for the two tracers sets being cross-correlated. </p>\n\n<p>For example, if you wish to compute the excess cross correlation for the joint {1,1}, {1,2} and {2,1}NN-CDFs, then set</p>\n\n<pre><code>k1_k2_list = [(1,1), (1,2), (2,1)]\n</code></pre>\n\n<p>Note that the inputs must be self-consistent, which means the following must be <code>True</code></p>\n\n<pre><code>len(joint_cdf_list)==len(auto_cdf_list_1) and len(joint_cdf_list)==len(auto_cdf_list_2) and len(joint_cdf_list)==len(k1_k2_list)\n</code></pre>\n\n<p>For example, if</p>\n\n<pre><code>k1_k2_list = [(1,1), (1,2)]\n</code></pre>\n\n<p>then</p>\n\n<pre><code>len(auto_cdf_list_1) == 2 and len(auto_cdf_list_2) == 2 and len(joint_cdf_list) == 2\n</code></pre>\n\n<p>must hold, and the first (second) element of <code>joint_cdf_list</code> should be the joint {1,1}NN-CDF ({1,2}NN-CDF).</p>\n\n<p>If <code>None</code> is passed for tracer-tracer cross-correlations, the correlations are assumed to be between the same NN indices (eg. {1,1}NN-CDF, {2,2}NN-CDF).</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour   distributions, <a href=\"https://doi.org/10.1093/mnras/stac3813\">Monthly Notices of the Royal Astronomical Society</a>, Volume 519, Issue 4, March 2023, Pages 4856\u20134868&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">auto_cdf_list_1</span>, </span><span class=\"param\"><span class=\"n\">auto_cdf_list_2</span>, </span><span class=\"param\"><span class=\"n\">joint_cdf_list</span>, </span><span class=\"param\"><span class=\"n\">k1_k2_list</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions_2DA", "modulename": "kNNpy.HelperFunctions_2DA", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.HelperFunctions_2DA.create_query_2DA", "modulename": "kNNpy.HelperFunctions_2DA", "qualname": "create_query_2DA", "kind": "function", "doc": "<p>Computes the usable query points for the given mask (ie., query points at least a user-defined \nthreshold distance away from the mask edge) and returns the same, along with a HEALPix \n<code>query mask</code> that has the following values:</p>\n\n<pre><code>0: pixels outside the observational footprint\n1: pixels inside the footprint but too close to the mask edge (not usable)\n2: usable pixels\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>NSIDE_query</strong> (int):\nthe HEALPix NSIDE of the query grid (needs to be the same as that of the continuous field and the mask). Must be a power of 2 (eg. 128, 256, 512, etc.).</li>\n<li><strong>mask</strong> (numpy float array of shape <code>(12*NSIDE_query**2, )</code>):\narray encoding the observational footprint associated with the data. The value of the mask should be <code>1.0</code> for HEALPixels inside the observational footprint and <code>healpy.UNSEEN</code> for HEALPixels outside the observational footprint. <code>healpy.UNSEEN = -1.6375e+30</code> is a special value for masked pixels used by the <code>healpy</code> package. If there is no observational footprint (for example, data such as gravitational wave catalogs that are all-sky, or simulated datasets), please enter an array with all values equal to <code>1.0</code>.</li>\n<li><strong>tolerance</strong> (float):\nthe minimum angular distance (in radians) a query point needs to be away from the mask edge\nto be considered usable.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>query_mask</strong> (numpy int array of shape <code>mask.shape</code>):\nthe HEALPix query mask, i.e., an array with 0, 1 and 2 indicating that the corresponding HEALPixel is outside the observational footprint, too close to mask boundary and sufficiently inside the observational footprint (far from the boundary), respectively.</li>\n<li><strong>QueryPositions</strong> (numpy float array of shape <code>(N_usable_pix, 2)</code>):\narray of usable query point positions, where 'N_usable_pix' is the number of pixels that are sufficiently far away from the mask edge, as determined by this method. For each query point in the array, the first (second) coordinate is the declination (right ascension) in radians.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if <code>tolerance</code> is not in <code>[0, 2*np.pi]</code></li>\n<li><strong>ValueError</strong>: if <code>NSIDE_query</code> is not a power of 2</li>\n<li><strong>ValueError</strong>: if <code>NSIDE_query</code> is not the same as the NSIDE of the continuous field and the mask</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.HelperFunctions.create_query_3D</code>:  generates query points in 3D.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Please refer to Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> for a detailed discussion on creation of query point in presence of observational footprints that do not cover the full sky. The algorithm currently supports only query grids of the same size as the HEALpix grid on which the continuous overdensity field skymap is defined.</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">NSIDE_query</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span>, </span><span class=\"param\"><span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions_2DA.bl_th", "modulename": "kNNpy.HelperFunctions_2DA", "qualname": "bl_th", "kind": "function", "doc": "<p>Computes Legendre expansion coefficients for the top-hat window function in angular coordinates.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>l</strong> (numpy int array):\narray of multipole numbers.</li>\n<li><strong>ss</strong> (float):\nangular scale (in radians) at which the field is to be smoothed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>numpy float array of shape <code>l.shape</code></strong>: array of Legendre expansion coefficients at each input multipole number.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">ss</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions_2DA.top_hat_smoothing_2DA", "modulename": "kNNpy.HelperFunctions_2DA", "qualname": "top_hat_smoothing_2DA", "kind": "function", "doc": "<p>Smooths the given map at the given scale using the top hat window function in harmonic space.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>skymap</strong> (numpy float array):\nthe healpy map of the continuous field that needs to be smoothed. The values of the masked pixels, if any, should be set to <code>healpy.UNSEEN</code>. <code>healpy.UNSEEN = -1.6375e+30</code> is a special value for masked pixels used by the <code>healpy</code> package.</li>\n<li><strong>scale</strong> (float):\nangular scale (in radians) at which the field is to be smoothed. Please ensure <code>scale</code> is between <code>0</code> and <code>2*np.pi</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>smoothed_map_masked</strong> (numpy float array of shape <code>skymap.shape</code>):\nthe smoothed healpy map, keeping the masked pixels of the original map masked.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if <code>scale</code> is not in <code>[0, 2*np.pi]</code></li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.HelperFunctions.smoothing_3d</code>:  performs smoothing operations in 3D.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The following expression is used to compute the the spherical harmonic expansion coefficients $\\alpha^{\\theta}_{\\ell m}$ of the field smoothed at angular scale $\\theta$ using a top hat window function (See Devaraju (2015)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> and Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">2</a></sup> for derivations and a detailed discussion)\n$$\\alpha^{\\theta}_{\\ell m} = 4\\pi\\frac{b_{\\ell}} {2\\ell+1}\\alpha_{\\ell m},$$\nwhere $b_{\\ell}$ are the the Legedre expansion coefficients of the top hat function, given by\n$$b_{\\ell} = \\frac{1}{4\\pi(1-\\cos\\theta)}\\left[P_{\\ell-1}(\\cos\\theta)-P_{\\ell+1}(\\cos\\theta)\\right].$$\nThe smoothed field is reconstructed from $\\alpha^{\\theta}_{\\ell m}$ using healpy's <code>alm2map</code> method.</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Devaraju B., 2015, <a href=\"http://elib.uni-stuttgart.de/handle/11682/4002\">doctoralThesis</a>, doi:10.18419/opus-3985.&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 2 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">skymap</span>, </span><span class=\"param\"><span class=\"n\">scale</span>, </span><span class=\"param\"><span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.HelperFunctions_2DA.create_smoothed_field_dict_2DA", "modulename": "kNNpy.HelperFunctions_2DA", "qualname": "create_smoothed_field_dict_2DA", "kind": "function", "doc": "<p>Creates a dictionary containing the continuous field smoothed at various angular distance scales.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>skymap</strong> (numpy float array):\nthe healpy map of the continuous field that needs to be smoothed. The values of the masked pixels, if any, should be set to <code>healpy.UNSEEN</code>. <code>healpy.UNSEEN = -1.6375e+30</code> is a special value for masked pixels used by the <code>healpy</code> package.</li>\n<li><strong>bins</strong> (list of numpy float array):\nlist of distances for each nearest neighbour. The $i^{th}$ element of the list should contain a numpy array of the desired distance scales for the $i^{th}$ nearest neighbour.</li>\n<li><strong>query_mask</strong> (numpy float array of shape <code>skymap.shape</code>):\nthe HEALPix query mask.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field masked within the observational footprint and smoothed at various angular distance scales. For example, <code>SmoothedFieldDict['0.215']</code>  represents the continuous map smoothed at a scale of 0.215 radians.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p><code>query_mask</code> is a numpy int array with 0, 1 and 2 indicating that the corresponding HEALPixel is outside the mask, too close to mask boundary and sufficiently far away from the boundary, respectively. Please Refer to the helper function method <code>create_query_2DA()</code> for creating the query mask. See also Gupta and Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> for a discussion.</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">skymap</span>, </span><span class=\"param\"><span class=\"n\">bins</span>, </span><span class=\"param\"><span class=\"n\">query_mask</span>, </span><span class=\"param\"><span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_2D_Ang", "modulename": "kNNpy.kNN_2D_Ang", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.kNN_2D_Ang.TracerAuto2DA", "modulename": "kNNpy.kNN_2D_Ang", "qualname": "TracerAuto2DA", "kind": "function", "doc": "<p>Computes the $k$NN-CDFs in 2D angular coordinates (Banerjee &amp; Abel (2021)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup>, Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">2</a></sup>) of the provided discrete tracer set (<code>MaskedTracerPosRad</code>), evaluated at the provided angular distance scales <code>BinsRad</code>, for all $k$ in <code>kList</code>. Each $k$NN-CDF measures the probability $P_{\\geq k}(\\theta)$ of finding at least $k$ tracers in a randomly placed spherical cap of radius $\\theta$. The $k$NN-CDFs quantify the spatial clustering of the tracers.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kList</strong> (int):\nthe list of nearest neighbours to calculate the distances to. For example, if <code>kList = [1, 2, 4]</code>, the first, second and fourth-nearest neighbour distributions will be computed.</li>\n<li><strong>BinsRad</strong> (list of numpy float array):\nlist of angular distance arrays (in radians) for each nearest neighbour. The $i^{th}$ element of the list should contain a numpy array of the desired distances for the nearest neighbour specified by the $i^{th}$ element of <code>kList</code>.</li>\n<li><strong>MaskedQueryPosRad</strong> (numpy float array of shape <code>(n_query, 2)</code>):\narray of sky locations for the query points. The sky locations must be on a grid. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>MaskedTracerPosRad</strong> (numpy float array of shape <code>(n_tracer, 2)</code>):\narray of sky locations for the discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>ReturnNNdist</strong> (bool, optional):\nif set to <code>True</code>, the sorted arrays of NN distances will be returned along with the $k$NN-CDFs, by default <code>False</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>kNN_results</strong> (tuple of lists | list of numpy float arrays):\nresults of the kNN computation. If <code>ReturnNNdist</code> is <code>True</code>, returns the tuple <code>(p_gtr_k_list, vol)</code> where <code>p_gtr_k_list</code> is the list of auto kNN-CDFs, and <code>vol</code> is the list of NN distances. If <code>ReturnNNdist</code> is <code>False</code>, returns <code>p_gtr_k_list</code> only</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the given query points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if declination of any of the query points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the query points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if declination of any of the tracer points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the tracer points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if the given tracer points are not on a two-dimensional grid.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Data with associated observational footprints are supported, in which case, only tracer positions within the footprint should be provided.Importantly, in this case, query points need to be within the footprint and appropriately padded from the edges of the footprint (see Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">3</a></sup> for a detailed discussion). See the <code>kNNpy.HelperFunctions.create_query_2DA()</code> method for help with masking and creating the modified query positions.</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Nearest neighbour distributions: New statistical measures for cosmological clustering, <a href=\"https://doi.org/10.1093/mnras/staa3604\">Monthly Notices of the Royal Astronomical Society</a>, Volume 500, Issue 4, February 2021, Pages 5479\u20135499&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 2 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 3 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kList</span>,</span><span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedQueryPosRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosRad</span>,</span><span class=\"param\">\t<span class=\"n\">ReturnNNdist</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_2D_Ang.TracerTracerCross2DA", "modulename": "kNNpy.kNN_2D_Ang", "qualname": "TracerTracerCross2DA", "kind": "function", "doc": "<p>Returns the probabilities $P_{\\geq k_A}$, $P_{\\geq k_B}$ and $P_{\\geq k_A, \\geq k_B}$ for ($k_A$, $k_B$) in <code>kA_kB_list</code> that quantify the extent of the spatial cross-correlation between the given sets of discrete tracers, <code>MaskedTracerPosRad_A</code>, <code>MaskedTracerPosRad_B</code>.</p>\n\n<ol>\n<li><p>$P_{\\geq k_A}(\\theta)$: \nthe $k_A$NN-CDF of the first set of discrete tracers, evaluated at angular distance scale $\\theta$</p></li>\n<li><p>$P_{\\geq k_B}(\\theta)$: \nthe $k_B$NN-CDF of the second set of discrete tracers, evaluated at angular distance scale $\\theta$</p></li>\n<li><p>$P_{\\geq k_A, \\geq k_B}(\\theta)$:\nthe joint probability of finding at least $k_A$ set A tracers and at least $k_B$ set B tracers within a spherical cap of radius $\\theta$</p></li>\n</ol>\n\n<p>The excess cross-correlation (Banerjee &amp; Abel 2023)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> can be computed trivially from the quatities (see the <code>kNNpy.HelperFunctions.kNN_excess_cross_corr()</code> method to do this)</p>\n\n<p>$$\\psi_{k_A, k_B} = P_{\\geq k_A, \\geq k_B}/(P_{\\geq k_A} \\times P_{\\geq k_B})$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kA_kB_list</strong> (list of int tuples):\nnearest-neighbour combinations for which the cross-correlations need to be computed (see notes for more details)</li>\n<li><strong>BinsRad</strong> (list of numpy float array):\nlist of angular distance scale arrays (in radians) for each nearest neighbour combination in <code>kA_kB_list</code>. The $i^{th}$ element of the list should contain a numpy array of the desired distances for the $i^{th}$ nearest neighbour combination.</li>\n<li><strong>MaskedQueryPosRad</strong> (numpy float array of shape <code>(n_query, 2)</code>):\narray of sky locations for the query points. The sky locations must be on a grid. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>MaskedTracerPosRad_A</strong> (numpy float array of shape <code>(n_tracer_A, 2)</code>):\narray of sky locations for the first set of discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>MaskedTracerPosRad_B</strong> (numpy float array of shape <code>(n_tracer_B, 2)</code>):\narray of sky locations for the second set of discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>p_gtr_kA_list</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the first set of discrete tracers evaluated at the desired distance bins. The $i^{th}$ element represents the $k_A^i$NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n<li><strong>p_gtr_kB_list</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the second set of discrete tracers evaluated at the desired distance bins. The $i^{th}$ element represents the $k_B^i$NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n<li><strong>p_gtr_kA_kB_list</strong> (list of numpy float arrays):\nlist of joint tracer-tracer nearest neighbour distributions evaluated at the desired distance bins. The $i^{th}$ element represents the joint {$k_A^i$, $k_B^i$}NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the lengths of <code>BinsRad</code> and <code>kA_kB_list</code> do not match.</li>\n<li><strong>ValueError</strong>: if the given query points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if declination of any of the query points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the query points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if declination of any of the tracer points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the tracer points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if any of the given tracer points are not on a two-dimensional grid.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.kNN_2D_Ang.TracerFieldCross2DA</code>:  computes tracer-field cross-correlations using the $k$NN formalism.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Measures the angular cross-correlation between two sets of discrete tracers using the k-nearest neighbour (kNN) formalism as defined in Banerjee &amp; Abel (2021)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">2</a></sup>.</p>\n\n<p>Data with associated observational footprints are supported, in which case, only tracer positions within the net footprint should be provided (if the two tracer sets have different footprints, a net footprint representing the intersection of the two footprints should be used). Importantly, in this case, query points need to be within the net footprint and appropriately padded from the edges of the footprint (see Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">3</a></sup> for a detailed discussion). Please refer to the <code>kNNpy.HelperFunctions.create_query_2DA()</code> method for help with masking and creating the modified query positions.</p>\n\n<p>The parameter <code>kA_kB_list</code> should provide the desired combinations of NN indices for the two tracers sets being cross-correlated. For example, if you wish to compute the joint {1,1}, {1,2} and {2,1}NN-CDFs, then set</p>\n\n<pre><code>kA_kB_list = [(1,1), (1,2), (2,1)]\n</code></pre>\n\n<p>Please note that if the number density of one set of tracers is significantly smaller than the other, the joint kNN-CDFs approach the auto kNN-CDFs of the less dense tracer set. In this scenario, it may be better to treat the denser tracer set as a continuous field and use the <code>TracerFieldCross2DA()</code> method instead to conduct the cross-correlation analysis  (see Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">4</a></sup> for a detailed discussion).</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Cosmological cross-correlations and nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stab961\">Monthly Notices of the Royal Astronomical Society</a>, Volume 504, Issue 2, June 2021, Pages 2911\u20132923&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Cosmological cross-correlations and nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stab961\">Monthly Notices of the Royal Astronomical Society</a>, Volume 504, Issue 2, June 2021, Pages 2911\u20132923&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 2 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 3 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 4 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kA_kB_list</span>,</span><span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedQueryPosRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosRad_A</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosRad_B</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_2D_Ang.TracerTracerCross2DA_DataVector", "modulename": "kNNpy.kNN_2D_Ang", "qualname": "TracerTracerCross2DA_DataVector", "kind": "function", "doc": "<p>Returns 'data vectors' of the probabilities $P_{\\geq k_A}$, $P_{\\geq k_B}$ and $P_{\\geq k_A, \\geq k_B}$ [refer to kNNpy.kNN_2D_Ang.TracerTracerCross2DA for definitions] for ($k_A$, $k_B$) in <code>kA_kB_list</code> for multiple realisations of discrete tracer A [<code>MaskedTracerPosVectorRad_A</code>] and a single realisation of the discrete tracer <code>MaskedTracerPosRad_B</code>. Please refer to notes to understand why this might be useful.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kA_kB_list</strong> (list of int tuples):\nnearest-neighbour combinations for which the cross-correlations need to be computed (see notes for more details)</li>\n<li><strong>BinsRad</strong> (list of numpy float array):\nlist of angular distance scale arrays (in radians) for each nearest neighbour combination in <code>kA_kB_list</code>. The $i^{th}$ element of the list should contain a numpy array of the desired distances for the $i^{th}$ nearest neighbour combination.</li>\n<li><strong>MaskedQueryPosRad</strong> (numpy float array of shape <code>(n_query, 2)</code>):\narray of sky locations for the query points. The sky locations must be on a grid. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>MaskedTracerPosVectorRad_A</strong> (numpy float array of shape <code>(n_realisations, n_tracer_A, 2)</code>):\narray of sky locations for the first set of discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>MaskedTracerPosRad_B</strong> (numpy float array of shape <code>(n_tracer_B, 2)</code>):\narray of sky locations for the second set of discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>p_gtr_kA_veclist</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the first set of discrete tracers evaluated at the desired distance bins. The $i^{th}$ element is a 2D array of shape <code>(n_realisations, n_bins)</code> containing the measured $k_A^i$NN-CDFs, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n<li><strong>p_gtr_kB_list</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the second set of discrete tracers evaluated at the desired distance bins. The $i^{th}$ element represents the $k_B^i$NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n<li><strong>p_gtr_kA_kB_veclist</strong> (list of numpy float arrays):\nlist of joint tracer-tracer nearest neighbour distributions evaluated at the desired distance bins. The $i^{th}$ element is a 2D array of shape <code>(n_realisations, n_bins)</code> containing the measured joint {$k_A^i$, $k_B^i$}NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the lengths of <code>BinsRad</code> and <code>kA_kB_list</code> do not match.</li>\n<li><strong>ValueError</strong>: if the given query points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if declination of any of the query points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the query points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if declination of any of the tracer points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the tracer points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if any of the given tracer points are not on a two-dimensional grid.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.kNN_2D_Ang.TracerTracerCross2DA</code>:  computes tracer-tracer cross-correlation for a single realisation of both tracers using the $k$NN formalism.<br />\n<code>kNNpy.kNN_2D_Ang.TracerFieldCross2DA_DataVector</code>:  computes tracer-field cross-correlation data vectors for multiple realisations of the tracer using the $k$NN formalism.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Please refer to the documentation of kNNpy.kNN_2D_Ang.TracerTracerCross2DA for important usage notes that also apply to this function and references. <Explain why cross-correlating multiple realisations of tracer A with single realisation of tracer B might be useful></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kA_kB_list</span>,</span><span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedQueryPosRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosVectorRad_A</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosRad_B</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_2D_Ang.TracerFieldCross2DA", "modulename": "kNNpy.kNN_2D_Ang", "qualname": "TracerFieldCross2DA", "kind": "function", "doc": "<p>Returns the probabilities $P_{\\geq k}$, $P_{&gt;{\\rm dt}}$ and $P_{\\geq k,&gt;{\\rm dt}}$ for $k$ in <code>kList</code>, that quantify the extent of the spatial cross-correlation between the given discrete tracer positions (<code>MaskedTracerPosRad</code>) and the given continuous overdensity field (<code>FieldSkymap</code>).</p>\n\n<ol>\n<li><p>$P_{\\geq k}(\\theta)$: \nthe kNN-CDF of the discrete tracers, evaluated at angular distance scale $\\theta$</p></li>\n<li><p>$P_{&gt;{\\rm dt}}(\\theta)$: \nthe probability of the overdensity field smoothed with a top-hat filter of angular size $\\theta$ exceeding the given constant percentile density threshold</p></li>\n<li><p>$P_{\\geq k, &gt;{\\rm dt}}(\\theta)$:\nthe joint probability of finding at least 'k' tracers within a spherical cap of radius $\\theta$ AND the overdensity field smoothed at angular scale $\\theta$ exceeding the given density threshold (as specified by the parameter <code>FieldConstPercThreshold</code>)</p></li>\n</ol>\n\n<p>The excess cross-correlation (Banerjee &amp; Abel 2023)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> can be computed trivially from the quatities (see the <code>kNNpy.HelperFunctions.kNN_excess_cross_corr()</code> method to do this)</p>\n\n<p>$$\\psi_{k, {\\rm dt}} = P_{\\geq k, &gt;{\\rm dt}}/(P_{\\geq k} \\times P_{&gt;{\\rm dt}})$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kList</strong> (int):\nthe list of nearest neighbours to calculate the distances to. For example, if <code>kList = [1, 2, 4]</code>, the first, second and fourth-nearest neighbour distributions will be computed.</li>\n<li><strong>BinsRad</strong> (list of numpy float array):\nlist of angular distance arrays (in radians) for each nearest neighbour. The $i^{th}$ element of the list should contain a numpy array of the desired distances for the nearest neighbour specified by the $i^{th}$ element of <code>kList</code>.</li>\n<li><strong>MaskedQueryPosRad</strong> (numpy float array of shape <code>(n_query, 2)</code>):\narray of sky locations for the query points. The sky locations must be on a grid. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>MaskedTracerPosRad</strong> (numpy float array of shape <code>(n_tracer, 2)</code>):\narray of sky locations for the discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>FieldSkymap</strong> (numpy float array):\nthe healpy map of the continuous field. The values of the masked pixels, if any, should be set to <code>hp.UNSEEN</code>.</li>\n<li><strong>QueryMask</strong> (numpy float array of shape <code>FieldSkymap.shape</code>):\nthe HEALPix query mask used to generate the masked query positions <code>MaskedQueryPosRad</code> (see kNNpy.HelperFunctions.create_query_2DA for how to compute this mask from an observational mask, and for a detailed description).</li>\n<li><strong>FieldConstPercThreshold</strong> (float):\nthe percentile value for the constant percentile threshold to be used for the continuous field. For example, <code>FieldConstPercThreshold = 75.0</code> represents a 75th percentile threshold.</li>\n<li><strong>ReturnSmoothedDict</strong> (bool, optional):\nif set to <code>True</code>, the dictionary containing the continuous field masked within the observational footprint, and smoothed at the provided angular distance scales, will be returned along with the nearest-neighbour measurements, by default <code>False</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>p_gtr_k_list</strong> (list of numpy float arrays):\nauto kNN-CDFs of the discrete tracers evaluated at the desired distance bins.</li>\n<li><strong>p_gtr_dt_list</strong> (list of numpy float arrays):\ncontinuum version of auto kNN-CDFs for the continuous field evaluated at the desired distance bins.</li>\n<li><strong>p_gtr_k_dt_list</strong> (list of numpy float arrays):\njoint tracer-field nearest neighbour distributions evaluated at the desired distance bins.</li>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field masked within the observational footprint and smoothed at the provided angular distance scales, returned only if <code>ReturnSmoothedDict</code> is <code>True</code>. For example, <code>SmoothedFieldDict['0.215']</code> represents the continuous map smoothed at a scale of 0.215 radians.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the given query points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if declination of any of the query points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the query points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if declination of any of the tracer points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the tracer points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if the given tracer points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if the shape of field skymap (after masking) does not match the shape of the given query point array.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.kNN_2D_Ang.TracerTracerCross2DA</code>:  computes tracer-tracer cross-correlations using the $k$NN formalism.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Measures the angular cross-correlation between a set of discrete tracers and a continuous overdensity field using the k-nearest neighbour (kNN) formalism as defined in Banerjee &amp; Abel (2023)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">2</a></sup> and Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">3</a></sup>.</p>\n\n<p>Currently, the algorithm requires a constant percentile overdensity threshold for the continuous field and query points to be defined on a HEALPix grid. Extentions to a constant mass threshold and poisson-sampled query points on the sky may be added in the future. </p>\n\n<p>Data with associated observational footprints are supported, in which case, only tracer positions within the footprint should be provided and the field should be masked appropriately.Importantly, in this case, query points need to be within the footprint and appropriately padded from the edges of the footprint (see Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">4</a></sup> for a detailed discussion). If the footprints of the tracer set and the field are different, a combined mask representing the intersection of the two footprints should be used (see the <code>kNNpy.HelperFunctions.create_query_2DA()</code> method for help with masking and creating the modified query positions).</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour   distributions, <a href=\"https://doi.org/10.1093/mnras/stac3813\">Monthly Notices of the Royal Astronomical Society</a>, Volume 519, Issue 4, March 2023, Pages 4856\u20134868&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour   distributions, <a href=\"https://doi.org/10.1093/mnras/stac3813\">Monthly Notices of the Royal Astronomical Society</a>, Volume 519, Issue 4, March 2023, Pages 4856\u20134868&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 2 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 3 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 4 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kList</span>,</span><span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedQueryPosRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosRad</span>,</span><span class=\"param\">\t<span class=\"n\">FieldSkymap</span>,</span><span class=\"param\">\t<span class=\"n\">QueryMask</span>,</span><span class=\"param\">\t<span class=\"n\">FieldConstPercThreshold</span>,</span><span class=\"param\">\t<span class=\"n\">ReturnSmoothedDict</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_2D_Ang.TracerFieldCross2DA_DataVector", "modulename": "kNNpy.kNN_2D_Ang", "qualname": "TracerFieldCross2DA_DataVector", "kind": "function", "doc": "<p>Returns 'data vectors' of the  the probabilities $P_{\\geq k}$, $P_{&gt;{\\rm dt}}$ and $P_{\\geq k,&gt;{\\rm dt}}$ [refer to kNNpy.kNN_2D_Ang.TracerFieldCross2DA for definitions] for $k$ in <code>kList</code> for multiple realisations of the given discrete tracer set [<code>MaskedTracerPosVectorRad</code>] and a single realisation of the given continuous overdensity field (<code>FieldSkymap</code>). Please refer to notes to understand why this might be useful.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kList</strong> (int):\nthe list of nearest neighbours to calculate the distances to. For example, if <code>kList = [1, 2, 4]</code>, the first, second and fourth-nearest neighbour distributions will be computed.</li>\n<li><strong>BinsRad</strong> (list of numpy float array):\nlist of angular distance arrays (in radians) for each nearest neighbour. The $i^{th}$ element of the list should contain a numpy array of the desired distances for the nearest neighbour specified by the $i^{th}$ element of <code>kList</code>.</li>\n<li><strong>MaskedQueryPosRad</strong> (numpy float array of shape <code>(n_query, 2)</code>):\narray of sky locations for the query points. The sky locations must be on a grid. For each query point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>MaskedTracerPosVectorRad</strong> (numpy float array of shape <code>(n_realisations, n_tracer, 2)</code>):\narray of sky locations for the first set of discrete tracers. For each data point in the array, the first (second) coordinate should be the declination (right ascension) in radians. Please ensure <code>-np.pi/2 &lt;= declination &lt;= pi/2</code> and <code>0 &lt;= right ascension &lt;= 2*np.pi</code>.</li>\n<li><strong>FieldSkymap</strong> (numpy float array):\nthe healpy map of the continuous field. The values of the masked pixels, if any, should be set to <code>hp.UNSEEN</code>.</li>\n<li><strong>QueryMask</strong> (numpy float array of shape <code>FieldSkymap.shape</code>):\nthe HEALPix query mask used to generate the masked query positions <code>MaskedQueryPosRad</code> (see kNNpy.HelperFunctions.create_query_2DA for how to compute this mask from an observational mask, and for a detailed description).</li>\n<li><strong>FieldConstPercThreshold</strong> (float):\nthe percentile value for the constant percentile threshold to be used for the continuous field. For example, <code>FieldConstPercThreshold = 75.0</code> represents a 75th percentile threshold.</li>\n<li><strong>ReturnSmoothedDict</strong> (bool, optional):\nif set to <code>True</code>, the dictionary containing the continuous field masked within the observational footprint, and smoothed at the provided angular distance scales, will be returned along with the nearest-neighbour measurements, by default <code>False</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>p_gtr_k_veclist</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the discrete tracers evaluated at the desired distance bins. Each list member is a 2D array of shape <code>(n_realisations, n_bins)</code>.</li>\n<li><strong>p_gtr_dt_list</strong> (list of numpy float arrays):\ncontinuum version of auto kNN-CDFs for the continuous field evaluated at the desired distance bins.</li>\n<li><strong>p_gtr_k_dt_veclist</strong> (list of numpy float arrays):\nlist of joint tracer-field nearest neighbour distributions evaluated at the desired distance bins. Each list member is a 2D array of shape <code>(n_realisations, n_bins)</code>.</li>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field masked within the observational footprint and smoothed at the provided angular distance scales, returned only if <code>ReturnSmoothedDict</code> is <code>True</code>. For example, <code>SmoothedFieldDict['0.215']</code> represents the continuous map smoothed at a scale of 0.215 radians.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the given query points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if declination of any of the query points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the query points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if declination of any of the tracer points is not in <code>[-np.pi/2, np.pi/2]</code>.</li>\n<li><strong>ValueError</strong>: if right ascension of any of the tracer points is not in <code>[0, 2*np.pi]</code>.</li>\n<li><strong>ValueError</strong>: if the given tracer points are not on a two-dimensional grid.</li>\n<li><strong>ValueError</strong>: if the shape of field skymap (after masking) does not match the shape of the given query point array.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNNpy.kNN_2D_Ang.TracerFieldCross2DA</code>:  computes tracer-field cross-correlations using the $k$NN formalism.<br />\n<code>kNNpy.kNN_2D_Ang.TracerTracerCross2DA_DataVector</code>:  computes tracer-tracer cross-correlation data vectors for multiple realisations of the first tracer and single realisation of the second tracer using the $k$NN formalism.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Please refer to the documentation of kNNpy.kNN_2D_Ang.TracerFieldCross2DA for important usage notes that also apply to this function and references. <Explain why cross-correlating multiple realisations of tracer with single realisation of field might be useful></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kList</span>,</span><span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedQueryPosRad</span>,</span><span class=\"param\">\t<span class=\"n\">MaskedTracerPosVectorRad</span>,</span><span class=\"param\">\t<span class=\"n\">FieldSkymap</span>,</span><span class=\"param\">\t<span class=\"n\">QueryMask</span>,</span><span class=\"param\">\t<span class=\"n\">FieldConstPercThreshold</span>,</span><span class=\"param\">\t<span class=\"n\">ReturnSmoothedDict</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_3D", "modulename": "kNNpy.kNN_3D", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNNpy.kNN_3D.TracerAuto3D", "modulename": "kNNpy.kNN_3D", "qualname": "TracerAuto3D", "kind": "function", "doc": "<p>Computes the $k$NN-CDFs in 3D coordinates (Banerjee &amp; Abel (2021)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup>) of the provided discrete tracer set (<code>TracerPos</code>), \nevaluated at the provided radial distance scales <code>BinsRad</code>, for all $k$ in <code>kList</code>. Each $k$NN-CDF measures the probability\n$P_{\\geq k}(r)$ of finding at least $k$ tracers in a randomly placed sphere of radius $r$. The $k$NN-CDFs quantify the spatial \nclustering of the tracers.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>boxsize</strong> (float):\nThe size of the cubic box (in comoving Mpc/h) in which the tracers and the continuous field are defined.</li>\n<li><strong>kList</strong> (list of ints):\nthe list of nearest neighbours to calculate the distances to. For example, if <code>kList = [1, 2, 4]</code>, the first, second and \nfourth-nearest neighbour distributions will be computed.</li>\n<li><strong>BinsRad</strong> (list of numpy float array):\nlist of radial distance arrays (in Mpc/h) for each nearest neighbour. The $i^{th}$ element of the \nlist should contain a numpy array of the desired distances for the nearest neighbour specified by the $i^{th}$ element of <code>kList</code>.</li>\n<li><strong>QueryPos</strong> (numpy float array of shape <code>(n_query, 3)</code>):\narray of 3D locations for the query points. The 3D locations must be on a grid. The format is (x,y,z) Cartesian coordinates. \nPlease ensure $0<x,y,z<boxsize$.</li>\n<li><strong>TracerPos</strong> (numpy float array of shape <code>(n_tracer, 3)</code>):\narray of 3D locations for the discrete tracers. The 3D locations must be on a grid. The format is (x,y,z) Cartesian coordinates. \nPlease ensure $0<x,y,z<boxsize$.</li>\n<li><strong>ReturnNNdist</strong> (bool, optional):\nif set to <code>True</code>, the sorted arrays of NN distances will be returned along with the $k$NN-CDFs, by default <code>False</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>kNN_results</strong> (tuple of lists or list of numpy float arrays):\nresults of the kNN computation. If <code>ReturnNNdist</code> is <code>True</code>, returns the tuple <code>(p_gtr_k_list, vol)</code> where <code>p_gtr_k_list</code> \nis the list of auto kNN-CDFs, and <code>vol</code> is the list of NN distances. If <code>ReturnNNdist</code> is <code>False</code>, returns <code>p_gtr_k_list</code> only</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the given query points are not on a three-dimensional grid.</li>\n<li><strong>ValueError</strong>: if x,y, or z coordinate of any of the query points is not in <code>[0, boxsize)</code>.</li>\n<li><strong>ValueError</strong>: if x,y, or z coordinate of any of the tracer points is not in <code>[0, boxsize)</code>..</li>\n<li><strong>ValueError</strong>: if the given tracer points are not on a three-dimensional grid.</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<p><a href=\"https://doi.org/10.1093/mnras/staa3604\">Monthly Notices of the Royal Astronomical Society</a>, Volume 500, Issue 4, February 2021, Pages 5479\u20135499</p>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Nearest neighbour distributions: New statistical measures for cosmological clustering,&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">boxsize</span>,</span><span class=\"param\">\t<span class=\"n\">kList</span>,</span><span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">QueryPos</span>,</span><span class=\"param\">\t<span class=\"n\">TracerPos</span>,</span><span class=\"param\">\t<span class=\"n\">ReturnNNdist</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_3D.TracerTracerCross3D", "modulename": "kNNpy.kNN_3D", "qualname": "TracerTracerCross3D", "kind": "function", "doc": "<p>Returns the probabilities $P_{\\geq k_A}$, $P_{\\geq k_B}$ and $P_{\\geq k_A, \\geq k_B}$ for ($k_A$, $k_B$) in <code>kA_kB_list</code> \nthat quantify the extent of the spatial cross-correlation between the given sets of discrete tracers, <code>TracerPos_A</code>, <code>TracerPos_B</code>.</p>\n\n<ol>\n<li><p>$P_{\\geq k_A}(r)$: \nthe $k_A$NN-CDF of the first set of discrete tracers, evaluated at radial distance scale $r$</p></li>\n<li><p>$P_{\\geq k_B}(\\theta)$: \nthe $k_B$NN-CDF of the second set of discrete tracers, evaluated at radial distance scale $r$</p></li>\n<li><p>$P_{\\geq k_A, \\geq k_B}(\\theta)$:\nthe joint probability of finding at least $k_A$ set A tracers and at least $k_B$ set B tracers within a sphere of radius $r$</p></li>\n</ol>\n\n<p>The excess cross-correlation (Banerjee &amp; Abel 2023)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> can be computed trivially from the quatities (see the <code>kNNpy.HelperFunctions.kNN_excess_cross_corr()</code> method to do this)</p>\n\n<p>$$\\psi_{k_A, k_B} = P_{\\geq k_A, \\geq k_B}/(P_{\\geq k_A} \\times P_{\\geq k_B})$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>boxszie</strong> (float):\nThe size of the cubic box (in comoving Mpc/h) in which the tracers and the continuous field are defined.</li>\n<li><strong>kA_kB_list</strong> (list of int tuples):\nnearest-neighbour combinations for which the cross-correlations need to be computed (see notes for more details)</li>\n<li><strong>BinsRad</strong> (list of numpy float array):\nlist of radial distance scale arrays (in Mpc/h) for each nearest neighbour combination in <code>kA_kB_list</code>. The $i^{th}$ element of the \nlist should contain a numpy array of the desired distances for the $i^{th}$ nearest neighbour combination.</li>\n<li><strong>QueryPos</strong> (numpy float array of shape <code>(n_query, 3)</code>):\narray of 3D locations for the query points. The 3D locations must be on a grid. The format is (x,y,z) Cartesian coordinates. \nPlease ensure $0<x,y,z<boxsize$.</li>\n<li><strong>TracerPos_A</strong> (numpy float array of shape <code>(n_tracer, 3)</code>):\narray of 3D locations for the first set of discrete tracers. The 3D locations must be on a grid. The format is (x,y,z) Cartesian coordinates. \nPlease ensure $0<x,y,z<boxsize$.</li>\n<li><strong>TracerPos_B</strong> (numpy float array of shape <code>(n_tracer, 3)</code>):\narray of 3D locations for the second set of discrete tracers. The 3D locations must be on a grid. The format is (x,y,z) Cartesian coordinates. \nPlease ensure $0<x,y,z<boxsize$.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>p_gtr_kA_list</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the first set of discrete tracers evaluated at the desired distance bins. The $i^{th}$ element represents the $k_A^i$NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n<li><strong>p_gtr_kB_list</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the second set of discrete tracers evaluated at the desired distance bins. The $i^{th}$ element represents the $k_B^i$NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n<li><strong>p_gtr_kA_kB_list</strong> (list of numpy float arrays):\nlist of joint tracer-tracer nearest neighbour distributions evaluated at the desired distance bins. The $i^{th}$ element represents the joint {$k_A^i$, $k_B^i$}NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the lengths of <code>BinsRad</code> and <code>kA_kB_list</code> do not match.</li>\n<li><strong>ValueError</strong>: if the given query points are not on a three-dimensional grid.</li>\n<li><strong>ValueError</strong>: if x,y, or z coordinates of any of the query points is not in <code>[0, boxsize)</code>.</li>\n<li><strong>ValueError</strong>: if x,y, or z coordinates of any of the tracer points is not in <code>[0, boxsize)</code>.</li>\n<li><strong>ValueError</strong>: if any of the given tracer points are not on a three-dimensional grid.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The parameter <code>kA_kB_list</code> should provide the desired combinations of NN indices for the two tracers sets being cross-correlated. For example, if you wish to compute the joint {1,1}, {1,2} and {2,1}NN-CDFs, then set</p>\n\n<pre><code>kA_kB_list = [(1,1), (1,2), (2,1)]\n</code></pre>\n\n<p>Please note that if the number density of one set of tracers is significantly smaller than the other, the joint kNN-CDFs approach the auto kNN-CDFs of the less dense tracer set. In this scenario, it may be better to treat the denser tracer set as a continuous field and use the <code>TracerFieldCross2DA()</code> method instead to conduct the cross-correlation analysis  (see Gupta &amp; Banerjee (2024)[^2] for a detailed discussion).</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Cosmological cross-correlations and nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stab961\">Monthly Notices of the Royal Astronomical Society</a>, Volume 504, Issue 2, June 2021, Pages 2911\u20132923&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">boxsize</span>,</span><span class=\"param\">\t<span class=\"n\">kA_kB_list</span>,</span><span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">QueryPos</span>,</span><span class=\"param\">\t<span class=\"n\">TracerPos_A</span>,</span><span class=\"param\">\t<span class=\"n\">TracerPos_B</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_3D.TracerTracerCross3D_DataVector", "modulename": "kNNpy.kNN_3D", "qualname": "TracerTracerCross3D_DataVector", "kind": "function", "doc": "<p>Returns the probabilities $P_{\\geq k_{A_i}}$, $P_{\\geq k_B}$ and $P_{\\geq k_{A_i}, \\geq k_B}$ for ($k_{A_i}$, $k_B$) in <code>kA_kB_list</code> for various \nrealizations of Tracer A, while keeping the set Tracer B constant. Refer to Notes to understand why this might be useful. These quantify\nthe extent of the spatial cross-correlation between the given sets of discrete tracers, the $i^{\\text{th}}$ realization of <code>TracerPos_A</code>, <code>TracerPos_B</code>.\nWe do not vary the 'kA_kB_list' as a function of the realizations of Tracer A.</p>\n\n<ol>\n<li><p>$P_{\\geq k_{A_i}}(r)$: \nthe $k_A$NN-CDF of the $i^{\\text{th}}$ realization of the first set of discrete tracers, evaluated at radial distance scale $r$</p></li>\n<li><p>$P_{\\geq k_B}(\\theta)$: \nthe $k_B$NN-CDF of the second set of discrete tracers, evaluated at radial distance scale $r$</p></li>\n<li><p>$P_{\\geq k_{A_i}, \\geq k_B}(\\theta)$:\nthe joint probability of finding at least $k_A$ set A tracers and at least $k_B$ set B tracers within a sphere of radius $r$, for the\n$i^{\\text{th}}$ realization of Tracer A</p></li>\n</ol>\n\n<p>The excess cross-correlation (Banerjee &amp; Abel 2023)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> can be computed trivially from the quatities (see the <code>kNNpy.HelperFunctions.kNN_excess_cross_corr()</code> method to do this)</p>\n\n<p>$$\\psi_{k_A, k_B} = P_{\\geq k_A, \\geq k_B}/(P_{\\geq k_A} \\times P_{\\geq k_B})$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>boxsize</strong> (float):\nThe size of the cubic box (in comoving Mpc/h) in which the tracers and the continuous field are defined.</li>\n<li><strong>kA_kB_list</strong> (list of int tuples):\nnearest-neighbour combinations for which the cross-correlations need to be computed (see notes for more details)</li>\n<li><strong>BinsRad</strong> (list of numpy float array):\nlist of radial distance scale arrays (in Mpc/h) for each nearest neighbour combination in <code>kA_kB_list</code>. The $i^{th}$ element of the \nlist should contain a numpy array of the desired distances for the $i^{th}$ nearest neighbour combination.</li>\n<li><strong>QueryPos</strong> (numpy float array of shape <code>(n_query, 3)</code>):\narray of 3D locations for the query points. The 3D locations must be on a grid. The format is (x,y,z) Cartesian coordinates. \nPlease ensure $0<x,y,z<boxsize$.</li>\n<li><strong>TracerPos_A_dict</strong> (dictionary, where each key corresponds to the realization, and stores the corresponding numpy array of size <code>(n_tracer,3)</code>, that):\nis the tracer positions for the $i^{\\text{th}}$ realization \nThe 3D locations must be on a grid. The format is (x,y,z) Cartesian coordinates. \nPlease ensure $0<x,y,z<boxsize$.</li>\n<li><strong>TracerPos_B</strong> (numpy float array of shape <code>(n_tracer, 3)</code>):\narray of 3D locations for the second set of discrete tracers. The 3D locations must be on a grid. The format is (x,y,z) Cartesian coordinates. \nPlease ensure $0<x,y,z<boxsize$.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><p><strong>Realizations</strong> (a numpy array of arrays where the $i^{\\text{th}}$ element corresponds to the 3D cross-correlation calculated between the $i^{\\text{th}}):</p></li>\n<li><p><strong>realization of Tracer A and Tracer B. The values correspond to an numpy array</strong> ([p_gtr_kA_list, p_gtr_kB_list, p_gtr_kA_kB_list]):</p></li>\n<li><p><strong>p_gtr_kA_list</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the first set of discrete tracers evaluated at the desired distance bins. The $i^{th}$ element represents the $k_A^i$NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</p></li>\n<li><strong>p_gtr_kB_list</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the second set of discrete tracers evaluated at the desired distance bins. The $i^{th}$ element represents the $k_B^i$NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n<li><strong>p_gtr_kA_kB_list</strong> (list of numpy float arrays):\nlist of joint tracer-tracer nearest neighbour distributions evaluated at the desired distance bins. The $i^{th}$ element represents the joint {$k_A^i$, $k_B^i$}NN-CDF, where the $i^{th}$ element of <code>kA_kB_list</code> is ($k_A^i$, $k_B^i$).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the lengths of <code>BinsRad</code> and <code>kA_kB_list</code> do not match.</li>\n<li><strong>ValueError</strong>: if the given query points are not on a three-dimensional grid.</li>\n<li><strong>ValueError</strong>: if x,y, or z coordinates of any of the query points is not in <code>[0, boxsize)</code>.</li>\n<li><strong>ValueError</strong>: if x,y, or z coordinates of any of the tracer points is not in `'[0, boxsize)``.</li>\n<li><strong>ValueError</strong>: if any of the given tracer points are not on a three-dimensional grid.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The parameter <code>kA_kB_list</code> should provide the desired combinations of NN indices for the two tracers sets being cross-correlated. For example, if you wish to compute the joint {1,1}, {1,2} and {2,1}NN-CDFs, then set</p>\n\n<pre><code>kA_kB_list = [(1,1), (1,2), (2,1)]\n</code></pre>\n\n<p>Please note that if the number density of one set of tracers is significantly smaller than the other, the joint kNN-CDFs approach the auto kNN-CDFs of the less dense tracer set. In this scenario, it may be better to treat the denser tracer set as a continuous field and use the <code>TracerFieldCross2DA()</code> method instead to conduct the cross-correlation analysis  (see Gupta &amp; Banerjee (2024)[^2] for a detailed discussion).</p>\n\n<h1 id=\"write-why-this-module-might-be-useful\">Write why this module might be useful</h1>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Cosmological cross-correlations and nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stab961\">Monthly Notices of the Royal Astronomical Society</a>, Volume 504, Issue 2, June 2021, Pages 2911\u20132923&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">boxsize</span>,</span><span class=\"param\">\t<span class=\"n\">kA_kB_list</span>,</span><span class=\"param\">\t<span class=\"n\">BinsRad</span>,</span><span class=\"param\">\t<span class=\"n\">QueryPos</span>,</span><span class=\"param\">\t<span class=\"n\">TracerPos_A_dict</span>,</span><span class=\"param\">\t<span class=\"n\">TracerPos_B</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_3D.TracerFieldCross3D", "modulename": "kNNpy.kNN_3D", "qualname": "TracerFieldCross3D", "kind": "function", "doc": "<p>Returns the probabilities $P_{\\geq k}$, $P_{&gt;{\\rm dt}}$ and $P_{\\geq k,&gt;{\\rm dt}}$ for $k$ in <code>kList</code>, that quantify the extent of the spatial cross-correlation between the given discrete tracer positions (<code>TracerPos</code>) and the given continuous overdensity field (<code>SmoothedFieldDict</code>) in three-dimensional space.</p>\n\n<ol>\n<li><p>$P_{\\geq k}(r)$: \nthe kNN-CDF of the discrete tracers, evaluated at separation $r$</p></li>\n<li><p>$P_{&gt;{\\rm dt}}(r)$: \nthe probability of the overdensity field smoothed with a top-hat filter of radius $r$ exceeding the given constant percentile density threshold</p></li>\n<li><p>$P_{\\geq k, &gt;{\\rm dt}}(r)$:\nthe joint probability of finding at least 'k' tracers within a sphere of radius $r$ AND the overdensity field smoothed at scale $r$ exceeding the given density threshold (as specified by the parameter <code>FieldConstPercThreshold</code>)</p></li>\n</ol>\n\n<p>The excess cross-correlation (Banerjee &amp; Abel 2023)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> can be computed trivially from these quantities:</p>\n\n<p>$$\\psi_{k, {\\rm dt}} = \\frac{P_{\\geq k, &gt;{\\rm dt}}}{P_{\\geq k} \\times P_{&gt;{\\rm dt}}}$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kList</strong> (list of int):\nList of nearest neighbours to compute. For example, if <code>kList = [1, 2, 4]</code>, the first, second and fourth-nearest neighbour distributions will be computed.</li>\n<li><strong>RBins</strong> (list of numpy float arrays):\nList of radial distance arrays (in comoving Mpc/$h$), one for each value in <code>kList</code>. The i-th element of the list should be a numpy array specifying the distances to be used for the nearest neighbour calculation corresponding to <code>kList[i]</code>.</li>\n<li><strong>BoxSize</strong> (float):\nThe size of the cubic box (in comoving Mpc/h) in which the tracers and the continuous field are defined.</li>\n<li><strong>QueryPos</strong> (numpy float array of shape <code>(n_query, 3)</code>):\nArray of 3D positions (e.g., in Cartesian coordinates) used to query the nearest-neighbour distances, and also compute field's CDF.</li>\n<li><strong>TracerPos</strong> (numpy float array of shape <code>(n_tracer, 3)</code>):\nArray of 3D positions of discrete tracers, with columns representing the x, y, and z coordinates, respectively.</li>\n<li><strong>Field3D</strong> (numpy float array of shape <code>(n_grid, n_grid, n_grid)</code>):\nA 3D numpy array representing the continuous field (for e.g., the matter overdensity field). The shape of the array should match the grid size used for smoothing.</li>\n<li><strong>FieldConstPercThreshold</strong> (float):\nThe percentile threshold for identifying overdense regions in the continuous field. For example, <code>75.0</code> indicates the 75th percentile.</li>\n<li><strong>ReturnSmoothedFieldDict</strong> (bool, optional):\nif set to <code>True</code>, the dictionary containing the continuous field smoothed at the provided radial bins, will be returned along with the nearest-neighbour measurements, by default <code>False</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nIf True, prints timing information for each step. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>p_gtr_k_list</strong> (list of numpy float arrays):\nAuto kNN-CDFs of the discrete tracers evaluated at the desired distance bins.</li>\n<li><strong>p_gtr_dt_list</strong> (list of numpy float arrays):\nOverdensity-field auto kNN-CDFs evaluated at the same scales.</li>\n<li><strong>p_gtr_k_dt_list</strong> (list of numpy float arrays):\nJoint CDFs of finding $\\geq k$ tracers AND field value exceeding the threshold at a given scale.</li>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field smoothed at the provided radial bins, returned only if <code>ReturnSmoothedDict</code> is <code>True</code>. For example, <code>SmoothedFieldDict['5']</code> represents the continuous map smoothed at a scale of 5 Mpc/h.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If TracerPos are not 3D.</li>\n<li><strong>ValueError</strong>: If QueryPos are not 3D.</li>\n<li><strong>ValueError</strong>: If tracer positions are outside the specified box size.</li>\n<li><strong>ValueError</strong>: If QueryPos are outside the specified box size.</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stac3813\">MNRAS</a>, Volume 519, Issue 4, March 2023, Pages 4856-4868&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kList</span>,</span><span class=\"param\">\t<span class=\"n\">RBins</span>,</span><span class=\"param\">\t<span class=\"n\">BoxSize</span>,</span><span class=\"param\">\t<span class=\"n\">QueryPos</span>,</span><span class=\"param\">\t<span class=\"n\">TracerPos</span>,</span><span class=\"param\">\t<span class=\"n\">Field3D</span>,</span><span class=\"param\">\t<span class=\"n\">FieldConstPercThreshold</span>,</span><span class=\"param\">\t<span class=\"n\">ReturnSmoothedFieldDict</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNNpy.kNN_3D.TracerFieldCross3D_DataVector", "modulename": "kNNpy.kNN_3D", "qualname": "TracerFieldCross3D_DataVector", "kind": "function", "doc": "<p>Returns 'data vectors' of the  the probabilities $P_{\\geq k}$, $P_{&gt;{\\rm dt}}$ and $P_{\\geq k,&gt;{\\rm dt}}$ [refer to kNNpy.kNN_3D.TracerFieldCross for definitions] for $k$ in <code>kList</code> for multiple realisations of the given discrete tracer set [<code>TracerPosVector</code>] and a single realisation of the given continuous overdensity field (<code>Field</code>). Please refer to notes to understand why this might be useful.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kList</strong> (list of int):\nList of nearest neighbours to compute. For example, if <code>kList = [1, 2, 4]</code>, the first, second and fourth-nearest neighbour distributions will be computed.</li>\n<li><strong>RBins</strong> (list of numpy float arrays):\nList of radial distance arrays (in comoving Mpc/$h$), one for each value in <code>kList</code>. The i-th element of the list should be a numpy array specifying the distances to be used for the nearest neighbour calculation corresponding to <code>kList[i]</code>.</li>\n<li><strong>BoxSize</strong> (float):\nThe size of the cubic box (in comoving Mpc/h) in which the tracers and the continuous field are defined.</li>\n<li><strong>QueryPos</strong> (numpy float array of shape <code>(n_query, 3)</code>):\nArray of 3D positions (e.g., in Cartesian coordinates) used to query the nearest-neighbour distances, and also compute field's CDF.</li>\n<li><strong>TracerPosVector</strong> (numpy float array of shape <code>(n_realisations, n_tracer, 3)</code>):\nArray of 3D positions of n_realisations of discrete tracers, with columns representing the x, y, and z coordinates, respectively.</li>\n<li><strong>Field</strong> (numpy float array of shape <code>(n_grid, n_grid, n_grid)</code>):\nA 3D numpy array representing the continuous field (for e.g., the matter overdensity field). The shape of the array should match the grid size used for smoothing.</li>\n<li><strong>FieldConstPercThreshold</strong> (float):\nThe percentile threshold for identifying overdense regions in the continuous field. For example, <code>75.0</code> indicates the 75th percentile.</li>\n<li><strong>ReturnSmoothedFieldDict</strong> (bool, optional):\nif set to <code>True</code>, the dictionary containing the continuous field smoothed at the provided radial bins, will be returned along with the nearest-neighbour measurements, by default <code>False</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nIf True, prints timing information for each step. Default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>p_gtr_k_veclist</strong> (list of numpy float arrays):\nlist of auto kNN-CDFs of the discrete tracers evaluated at the desired distance bins. Each list member is a 2D array of shape <code>(n_realisations, n_bins)</code>.</li>\n<li><strong>p_gtr_dt_list</strong> (list of numpy float arrays):\ncontinuum version of auto kNN-CDFs for the continuous field evaluated at the desired distance bins.</li>\n<li><strong>p_gtr_k_dt_veclist</strong> (list of numpy float arrays):\nlist of joint tracer-field nearest neighbour distributions evaluated at the desired distance bins. Each list member is a 2D array of shape <code>(n_realisations, n_bins)</code>.</li>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field smoothed at the provided radial bins, returned only if <code>ReturnSmoothedDict</code> is <code>True</code>. For example, <code>SmoothedFieldDict['5']</code> represents the continuous map smoothed at a scale of 5 Mpc/h.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If TracerPos are not on a 3dimensional grid.</li>\n<li><strong>ValueError</strong>: If QueryPos are not on a 3dimensional grid.</li>\n<li><strong>ValueError</strong>: If tracer positions are outside the specified box size.</li>\n<li><strong>ValueError</strong>: If QueryPos are outside the specified box size.</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kList</span>,</span><span class=\"param\">\t<span class=\"n\">RBins</span>,</span><span class=\"param\">\t<span class=\"n\">BoxSize</span>,</span><span class=\"param\">\t<span class=\"n\">QueryPos</span>,</span><span class=\"param\">\t<span class=\"n\">TracerPosVector</span>,</span><span class=\"param\">\t<span class=\"n\">Field</span>,</span><span class=\"param\">\t<span class=\"n\">FieldConstPercThreshold</span>,</span><span class=\"param\">\t<span class=\"n\">ReturnSmoothedDict</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();