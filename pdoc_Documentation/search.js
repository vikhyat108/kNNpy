window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "kNN_ASMR", "modulename": "kNN_ASMR", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNN_ASMR.HelperFunctions", "modulename": "kNN_ASMR.HelperFunctions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNN_ASMR.HelperFunctions.cdf_vol_knn", "modulename": "kNN_ASMR.HelperFunctions", "qualname": "cdf_vol_knn", "kind": "function", "doc": "<p>Returns interpolating functions for empirical CDFs of the given $k$-nearest neighbour distances.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vol</strong> (numpy float array of shape <code>(n_query, n_kNN)</code>):\nSorted array of nearest neighbour distances, where 'n_query' is the number of query points and 'n_kNN' is the number of nearest neighbours queried.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>cdf</strong> (list of function objects):\nlist of interpolated empirical CDF functions that can be evaluated at desired distance bins.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions.calc_kNN_CDF", "modulename": "kNN_ASMR.HelperFunctions", "qualname": "calc_kNN_CDF", "kind": "function", "doc": "<p>Returns the kNN-CDFs for the given nearest-neighbour distances, evaluated at the given distance bins.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vol</strong> (numpy float array of shape <code>(n_query, n_kNN)</code>):\n2D array containing sorted 1D arrays of nearest-neighbour distances, where 'n_query' is the number of query points and 'n_kNN' is the number of nearest-neighbours queried. <code>vol[:, i]</code> should be the array with the sorted $k_i^{th}$ nearest-neighbour distances.</li>\n<li><strong>bins</strong> (list of numpy float array):\nlist of distance scale arrays at which the CDFs need to be evaluated (units must be same as in <code>vol</code>).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>data</strong> (list of numpy float array):\nkNN-CDFs evaluated at the desired distance bins. <code>data[i]</code> is the $k_i$NN-CDF if <code>vol[:, i]</code> containts the $k_i^{th}$ nearest-neigbour distances.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vol</span>, </span><span class=\"param\"><span class=\"n\">bins</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions.create_query_3D", "modulename": "kNN_ASMR.HelperFunctions", "qualname": "create_query_3D", "kind": "function", "doc": "<p>Generates an array of query points; can be either randomly drawn from a uniform distribution defined over the box or put on a uniform grid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>query_type</strong> ({'grid', 'random'}, str):\nthe type of query points to be generated; should be 'grid' for query points defined on a uniform grid and 'random' for query points drawn from a uniform random distribution.</li>\n<li><strong>query_grid</strong> (int):\nthe 1D size of the query points array; the total number of query points generated will be <code>query_grid**3</code>.</li>\n<li><strong>BoxSize</strong> (float):\nthe size of the 3D box of the input density field, in Mpc/h.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>query_pos</strong> (numpy float array of shape <code>(query_grid**3, 3)</code>):\narray of query point positions. For each query point in the array, the first, second and third entries are the x, y and z coordinates respectively, in Mpc/h.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if an unknown query type is provided.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNN_ASMR.HelperFunctions.create_query_2DA</code>:  generates query points in 2D angular coordinates.  </p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">query_type</span>, </span><span class=\"param\"><span class=\"n\">query_grid</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions.smoothing_3D", "modulename": "kNN_ASMR.HelperFunctions", "qualname": "smoothing_3D", "kind": "function", "doc": "<p>Smooths the given map at the given scale using a window function of choice in real or k-space. </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>field</strong> (numpy float array):\nthe 3D array of the continuous field that needs to be smoothed.</li>\n<li><strong>Filter</strong> (string):\nthe filter to be used for smoothing. 'Top-Hat', 'Gaussian', 'Shell' are for real space, and 'Top-Hat-k' is a top-hat filter in k-space.</li>\n<li><strong>grid</strong> (int):\nthe grid size of the input density field, which should be field.shape[0] assuming a cubical box.</li>\n<li><strong>BoxSize</strong> (float):\nthe size of the 3D box of the input density field, in Mpc/h.</li>\n<li><strong>R</strong> (float, optional):\nradial scale (in Mpc/h) at which the field is to be smoothed. Only use this parameter for real space smoothing.</li>\n<li><strong>kmin</strong> (float, optional):\nthe minimum value of the wavenumber. Only use this parameter when 'Top-Hat-k' filter is used.</li>\n<li><strong>kmax</strong> (float, optional):\nthe maximum value of the wavenumber. Only use this parameter when 'Top-Hat-k' filter is used.</li>\n<li><strong>thickness</strong> (float, optional):\nthe thickness of the shell used for smoothing. Only use this parameter when 'Shell' filter is used. The smoothing is done using a shell with inner radius R-thickness/2 and outer radius R+thickness/2.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to True, the time taken to complete each step of the calculation will be printed, by default False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>smoothed_field</strong> (numpy float array of shape field.shape):\nthe smoothed field.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If required parameters (like R, kmin, kmax, or thickness) are missing for the specified filter type.</li>\n<li><strong>ValueError</strong>: If the input field dimensions do not form a cubical box.</li>\n<li><strong>ValueError</strong>: If the grid size does not match the field dimensions.</li>\n<li><strong>ValueError</strong>: If an unknown filter name is provided.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For real-space filters ('Top-Hat', 'Gaussian', 'Shell'), the radial scale R must be specified.</li>\n<li>For the 'Shell' filter, thickness must also be specified.</li>\n<li>For the 'Top-Hat-k' filter in Fourier space, kmin and kmax must be specified, while R and thickness are ignored.</li>\n<li>Any unused parameters will trigger warnings but not stop execution.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">field</span>,</span><span class=\"param\">\t<span class=\"n\">Filter</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span>,</span><span class=\"param\">\t<span class=\"n\">BoxSize</span>,</span><span class=\"param\">\t<span class=\"n\">R</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kmin</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kmax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">thickness</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions.create_smoothed_field_dict_3D", "modulename": "kNN_ASMR.HelperFunctions", "qualname": "create_smoothed_field_dict_3D", "kind": "function", "doc": "<p>Creates a dictionary containing the continuous field smoothed at various radial distance scales.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>field</strong> (numpy float array):\nthe 3D array of the continuous field that needs to be smoothed.</li>\n<li><strong>Filter</strong> (string):\nthe filter to be used for smoothing. 'Top-Hat', 'Gaussian', 'Shell' are for real space, and 'Top-Hat-k' is a top-hat filter in k-space.</li>\n<li><strong>grid</strong> (int):\nthe grid size of the input density field, which should be field.shape[0] assuming a cubical box.</li>\n<li><strong>BoxSize</strong> (float):\nthe size of the 3D box of the input density field, in Mpc/h.</li>\n<li><strong>bins</strong> (list of numpy float array):\nlist of distances for each nearest neighbour. The $i^{th}$ element of the list should contain a numpy array of the desired distance scales for the $k_i^{th}$ nearest neighbour.</li>\n<li><strong>kmin</strong> (float, optional):\nthe minimum value of the wavenumber. Only use this parameter when 'Top-Hat-k' filter is used.</li>\n<li><strong>kmax</strong> (float, optional):\nthe maximum value of the wavenumber. Only use this parameter when 'Top-Hat-k' filter is used.</li>\n<li><strong>thickness</strong> (float, optional):\nthe thickness of the shell used for smoothing. Only use this parameter when 'Shell' filter is used. The smoothing is done using a shell with inner radius R-thickness/2 and outer radius R+thickness/2.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to True, the time taken to complete each step of the calculation will be printed, by default False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field smoothed at various radial distance scales. For example, <code>SmoothedFieldDict['50.0']</code>  represents the continuous map smoothed at a scale of 50 Mpc/h.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If required parameters (like R, kmin, kmax, or thickness) are missing for the specified filter type.</li>\n<li><strong>ValueError</strong>: If the input field dimensions do not form a cubical box.</li>\n<li><strong>ValueError</strong>: If the grid size does not match the field dimensions.</li>\n<li><strong>ValueError</strong>: If an unknown filter name is provided.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>For real-space filters ('Top-Hat', 'Gaussian', 'Shell'), the radial scale R must be specified.</li>\n<li>For the 'Shell' filter, thickness must also be specified.</li>\n<li>For the 'Top-Hat-k' filter in Fourier space, kmin and kmax must be specified, while R and thickness are ignored.</li>\n<li>Any unused parameters will trigger warnings but not stop execution.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">field</span>,</span><span class=\"param\">\t<span class=\"n\">Filter</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span>,</span><span class=\"param\">\t<span class=\"n\">BoxSize</span>,</span><span class=\"param\">\t<span class=\"n\">bins</span>,</span><span class=\"param\">\t<span class=\"n\">kmin</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kmax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">thickness</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions.CIC_3D_Interp", "modulename": "kNN_ASMR.HelperFunctions", "qualname": "CIC_3D_Interp", "kind": "function", "doc": "<p>Interpolates a 3D field onto particle positions using Cloud-In-Cell (CIC) interpolation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>field</strong> (numpy.ndarray of shape <code>(Ng, Ng, Ng)</code>):\nThe 3D scalar field defined on a cubic grid with resolution 'Ng^3'.</li>\n<li><strong>pos</strong> (numpy.ndarray of shape <code>(Np, 3)</code>):\nThe positions of 'Np' particles. The columns represent x, y, and z coordinates. Units in Mpc/h</li>\n<li><strong>Boxsize</strong> (float):\nThe side length of the cubic volume in the same units as <code>pos</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fieldI</strong> (numpy.ndarray of shape <code>(Np,)</code>):\nThe interpolated field values at the given particle positions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pos</span>, </span><span class=\"param\"><span class=\"n\">field</span>, </span><span class=\"param\"><span class=\"n\">Boxsize</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions.kNN_excess_cross_corr", "modulename": "kNN_ASMR.HelperFunctions", "qualname": "kNN_excess_cross_corr", "kind": "function", "doc": "<p>Computes the excess spatial cross-correlation (Banerjee &amp; Abel 2023)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> between two tracers (discrete or continuous) from their joint kNN distributions (<code>joint_cdf_list</code>) and their respective kNN-CDFs (<code>auto_cdf_list_1</code>, <code>auto_cdf_list_2</code>).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>auto_cdf_list_1</strong> (list of numpy float array):\nauto kNN-CDFs of the first set of tracers. If <code>k1_k2_list</code> is not <code>None</code>, The $i^{th}$ element should be the $k_1^i$NN-CDF if the $i^{th}$ element of <code>k1_k2_list</code> is ($k_1^i$, $k_2^i$).</li>\n<li><strong>auto_cdf_list_2</strong> (list of numpy float array):\nauto kNN-CDFs of the second set of tracers. If <code>k1_k2_list</code> is not <code>None</code>, The $i^{th}$ element should be the $k_2^i$NN-CDF if where the $i^{th}$ element of <code>k1_k2_list</code> is ($k_1^i$, $k_2^i$).</li>\n<li><strong>joint_cdf_list</strong> (list of numpy float array):\njoint kNN distributions of the two tracer sets. If <code>k1_k2_list</code> is not <code>None</code>, The $i^{th}$ element should be the joint {$k_1^i$, $k_2^i$}NN-CDF, where the $i^{th}$ element of <code>k1_k2_list</code> is ($k_1^i$, $k_2^i$).</li>\n<li><strong>k1_k2_list</strong> (list of int tuples):\ndescribes the kind of cross-correlations being computed (see notes for more details), by default <code>None</code>. Should be not None only if dealing with tracer-tracer cross-correlations</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>psi_list</strong> (list of numpy float array):\nexcess spatial cross-correlation between the two tracer sets.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if <code>k1_k2_list</code> is not <code>None</code> and <code>len(joint_cdf_list)!=len(k1_k2_list)</code></li>\n<li><strong>ValueError</strong>: if <code>k1_k2_list</code> is <code>None</code> and <code>len(joint_cdf_list)!=len(auto_cdf_list_1) or len(joint_cdf_list)!=len(auto_cdf_list_2)</code></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The parameter <code>k1_k2_list</code> describes the kind of cross-correlations being computed. It should be set to <code>None</code> for every scenario other than tracer-tracer cross-correlation, in which case it should provide the combinations of NN indices for the two tracers sets being cross-correlated. </p>\n\n<p>For example, if you wish to compute the excess cross correlation for the joint {1,1}, {1,2} and {2,1}NN-CDFs, then set</p>\n\n<pre><code>k1_k2_list = [(1,1), (1,2), (2,1)]\n</code></pre>\n\n<p>Note that the inputs must be self-consistent, which means the following must be <code>True</code></p>\n\n<pre><code>len(joint_cdf_list)==len(auto_cdf_list_1) and len(joint_cdf_list)==len(auto_cdf_list_2) and len(joint_cdf_list)==len(k1_k2_list)\n</code></pre>\n\n<p>For example, if</p>\n\n<pre><code>k1_k2_list = [(1,1), (1,2)]\n</code></pre>\n\n<p>then</p>\n\n<pre><code>len(auto_cdf_list_1) == 2 and len(auto_cdf_list_2) == 2 and len(joint_cdf_list) == 2\n</code></pre>\n\n<p>must hold, and the first (second) element of <code>joint_cdf_list</code> should be the joint {1,1}NN-CDF ({1,2}NN-CDF).</p>\n\n<p>If <code>None</code> is passed for tracer-tracer cross-correlations, the correlations are assumed to be between the same NN indices (eg. {1,1}NN-CDF, {2,2}NN-CDF).</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Arka Banerjee, Tom Abel, Tracer-field cross-correlations with k-nearest neighbour   distributions, <a href=\"https://doi.org/10.1093/mnras/stac3813\">Monthly Notices of the Royal Astronomical Society</a>, Volume 519, Issue 4, March 2023, Pages 4856\u20134868&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">auto_cdf_list_1</span>, </span><span class=\"param\"><span class=\"n\">auto_cdf_list_2</span>, </span><span class=\"param\"><span class=\"n\">joint_cdf_list</span>, </span><span class=\"param\"><span class=\"n\">k1_k2_list</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions_2DA", "modulename": "kNN_ASMR.HelperFunctions_2DA", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "kNN_ASMR.HelperFunctions_2DA.create_query_2DA", "modulename": "kNN_ASMR.HelperFunctions_2DA", "qualname": "create_query_2DA", "kind": "function", "doc": "<p>Computes the usable query points for the given mask (ie., query points at least a user-defined \nthreshold distance away from the mask edge) and returns the same, along with a HEALPix \n<code>query mask</code> that has the following values:</p>\n\n<pre><code>0: pixels outside the observational footprint\n1: pixels inside the footprint but too close to the mask edge (not usable)\n2: usable pixels\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>NSIDE_query</strong> (int):\nthe HEALPix NSIDE of the query grid (needs to be the same as that of the continuous field and the mask). Must be a power of 2 (eg. 128, 256, 512, etc.).</li>\n<li><strong>mask</strong> (numpy float array of shape <code>(12*NSIDE_query**2, )</code>):\narray encoding the observational footprint associated with the data. The value of the mask should be <code>1.0</code> for HEALPixels inside the observational footprint and <code>healpy.UNSEEN</code> for HEALPixels outside the observational footprint. <code>healpy.UNSEEN = -1.6375e+30</code> is a special value for masked pixels used by the <code>healpy</code> package. If there is no observational footprint (for example, data such as gravitational wave catalogs that are all-sky, or simulated datasets), please enter an array with all values equal to <code>1.0</code>.</li>\n<li><strong>tolerance</strong> (float):\nthe minimum angular distance (in radians) a query point needs to be away from the mask edge\nto be considered usable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>query_mask</strong> (numpy int array of shape <code>mask.shape</code>):\nthe HEALPix query mask, i.e., an array with 0, 1 and 2 indicating that the corresponding HEALPixel is outside the observational footprint, too close to mask boundary and sufficiently inside the observational footprint (far from the boundary), respectively.</li>\n<li><strong>QueryPositions</strong> (numpy float array of shape <code>(N_usable_pix, 2)</code>):\narray of usable query point positions, where 'N_usable_pix' is the number of pixels that are sufficiently far away from the mask edge, as determined by this method. For each query point in the array, the first (second) coordinate is the declination (right ascension) in radians.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if <code>tolerance</code> is not in <code>[0, 2*np.pi]</code></li>\n<li><strong>ValueError</strong>: if <code>NSIDE_query</code> is not a power of 2</li>\n<li><strong>ValueError</strong>: if <code>NSIDE_query</code> is not the same as the NSIDE of the continuous field and the mask</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNN_ASMR.HelperFunctions.create_query_3D</code>:  generates query points in 3D.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Please refer to Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> for a detailed discussion on creation of query point in presence of observational footprints that do not cover the full sky. The algorithm currently supports only query grids of the same size as the HEALpix grid on which the continuous overdensity field skymap is defined.</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">NSIDE_query</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions_2DA.bl_th", "modulename": "kNN_ASMR.HelperFunctions_2DA", "qualname": "bl_th", "kind": "function", "doc": "<p>Computes Legendre expansion coefficients for the top-hat window function in angular coordinates.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>l</strong> (numpy int array):\narray of multipole numbers.</li>\n<li><strong>ss</strong> (float):\nangular scale (in radians) at which the field is to be smoothed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>numpy float array of shape <code>l.shape</code></strong>: array of Legendre expansion coefficients at each input multipole number.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">ss</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions_2DA.top_hat_smoothing_2DA", "modulename": "kNN_ASMR.HelperFunctions_2DA", "qualname": "top_hat_smoothing_2DA", "kind": "function", "doc": "<p>Smooths the given map at the given scale using the top hat window function in harmonic space.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>skymap</strong> (numpy float array):\nthe healpy map of the continuous field that needs to be smoothed. The values of the masked pixels, if any, should be set to <code>healpy.UNSEEN</code>. <code>healpy.UNSEEN = -1.6375e+30</code> is a special value for masked pixels used by the <code>healpy</code> package.</li>\n<li><strong>scale</strong> (float):\nangular scale (in radians) at which the field is to be smoothed. Please ensure <code>scale</code> is between <code>0</code> and <code>2*np.pi</code>.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>smoothed_map_masked</strong> (numpy float array of shape <code>skymap.shape</code>):\nthe smoothed healpy map, keeping the masked pixels of the original map masked.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if <code>scale</code> is not in <code>[0, 2*np.pi]</code></li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>kNN_ASMR.HelperFunctions.smoothing_3d</code>:  performs smoothing operations in 3D.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The following expression is used to compute the the spherical harmonic expansion coefficients $\\alpha^{\\theta}_{\\ell m}$ of the field smoothed at angular scale $\\theta$ using a top hat window function (See Devaraju (2015)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> and Gupta &amp; Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-2\"><a href=\"#fn-2\">2</a></sup> for derivations and a detailed discussion)\n$$\\alpha^{\\theta}_{\\ell m} = 4\\pi\\frac{b_{\\ell}} {2\\ell+1}\\alpha_{\\ell m},$$\nwhere $b_{\\ell}$ are the the Legedre expansion coefficients of the top hat function, given by\n$$b_{\\ell} = \\frac{1}{4\\pi(1-\\cos\\theta)}\\left[P_{\\ell-1}(\\cos\\theta)-P_{\\ell+1}(\\cos\\theta)\\right].$$\nThe smoothed field is reconstructed from $\\alpha^{\\theta}_{\\ell m}$ using healpy's <code>alm2map</code> method.</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Devaraju B., 2015, <a href=\"http://elib.uni-stuttgart.de/handle/11682/4002\">doctoralThesis</a>, doi:10.18419/opus-3985.&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n\n<li id=\"fn-2\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-2\" class=\"footnoteBackLink\" title=\"Jump back to footnote 2 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">skymap</span>, </span><span class=\"param\"><span class=\"n\">scale</span>, </span><span class=\"param\"><span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "kNN_ASMR.HelperFunctions_2DA.create_smoothed_field_dict_2DA", "modulename": "kNN_ASMR.HelperFunctions_2DA", "qualname": "create_smoothed_field_dict_2DA", "kind": "function", "doc": "<p>Creates a dictionary containing the continuous field smoothed at various angular distance scales.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>skymap</strong> (numpy float array):\nthe healpy map of the continuous field that needs to be smoothed. The values of the masked pixels, if any, should be set to <code>healpy.UNSEEN</code>. <code>healpy.UNSEEN = -1.6375e+30</code> is a special value for masked pixels used by the <code>healpy</code> package.</li>\n<li><strong>bins</strong> (list of numpy float array):\nlist of distances for each nearest neighbour. The $i^{th}$ element of the list should contain a numpy array of the desired distance scales for the $i^{th}$ nearest neighbour.</li>\n<li><strong>query_mask</strong> (numpy float array of shape <code>skymap.shape</code>):\nthe HEALPix query mask.</li>\n<li><strong>Verbose</strong> (bool, optional):\nif set to <code>True</code>, the time taken to complete each step of the calculation will be printed, by default <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>SmoothedFieldDict</strong> (dict):\ndictionary containing the continuous field masked within the observational footprint and smoothed at various angular distance scales. For example, <code>SmoothedFieldDict['0.215']</code>  represents the continuous map smoothed at a scale of 0.215 radians.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p><code>query_mask</code> is a numpy int array with 0, 1 and 2 indicating that the corresponding HEALPixel is outside the mask, too close to mask boundary and sufficiently far away from the boundary, respectively. Please Refer to the helper function method <code>create_query_2DA()</code> for creating the query mask. See also Gupta and Banerjee (2024)<sup class=\"footnote-ref\" id=\"fnref-1\"><a href=\"#fn-1\">1</a></sup> for a discussion.</p>\n\n<h6 id=\"references\">References</h6>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Kaustubh Rajesh Gupta, Arka Banerjee, Spatial clustering of gravitational wave sources with k-nearest neighbour distributions, <a href=\"https://doi.org/10.1093/mnras/stae1424\">Monthly Notices of the Royal Astronomical Society</a>, Volume 531, Issue 4, July 2024, Pages 4619\u20134639&#160;<a href=\"#fnref-1\" class=\"footnoteBackLink\" title=\"Jump back to footnote 1 in the text.\">&#8617;</a></p>\n</li>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">skymap</span>, </span><span class=\"param\"><span class=\"n\">bins</span>, </span><span class=\"param\"><span class=\"n\">query_mask</span>, </span><span class=\"param\"><span class=\"n\">Verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();